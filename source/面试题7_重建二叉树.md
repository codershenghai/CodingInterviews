# 题目描述

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

例如，给出：

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```


返回如下的二叉树：

```python
	3
   / \
  9  20
    /  \
   15   7
```
# 题解

根据前序遍历序列的第一个值，将中序遍历的序列分成两部分。左边的子序列就是根节点的左子树中序遍历的结果，右边的子序列就是根节点的右子树中序遍历的结果。然后继续对两个子树递归求解即可。

为了方便递归，使用一个辅助函数，传入子序列开始的下标和结束的下标。这道题比较麻烦的是下标的处理，为此，记录左子树序列的长度，方便下标的计算。

```java
public TreeNode buildTree(int[] pre, int[] in) {
    return buildTreeHelper(pre, 0, pre.length-1, in, 0, in.length-1);
}

private TreeNode buildTreeHelper(int[] pre, int preStart, int preEnd, int[] in, int inStart, int inEnd) {
    if (preStart > preEnd || inStart > inEnd)
        return null;
    TreeNode root = new TreeNode(pre[preStart]);
    for (int i = inStart; i <= inEnd; i++) {
        if (in[i] == pre[preStart]) {
            int leftTreeSize = i - inStart;
            root.left = buildTreeHelper(pre, preStart+1, preStart+leftTreeSize,
                                        in, inStart, i-1);
            root.right = buildTreeHelper(pre, preStart+leftTreeSize+1, preEnd,
                                         in, i+1, inEnd);
        }
    }
    return root;
}
```