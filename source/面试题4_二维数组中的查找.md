# 题目描述

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

示例：

```
现有矩阵 matrix 如下：

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```

# 题解

二维数组是矩形的，有四个边角。很自然的想到，如果要开始查找，从哪个边角开始比较好呢？

如果从左上角开始查找，数字向右和向下都是递增的，我们不知道应该往哪里走，无法缩小查找的范围。同理，从右下角开始也是一样的，数字向左和向上都是递减的，也无法缩小查找的范围。

如果从右上角开始查找，数字向左递减向下递增，我们可以将要查找的数字和右上角这个数字进行对比，若两者相等，则查找结束。如果要查找的数字大于右上角的数字，则删除右上角的数字所在的行。如果要查找的数字小于右上角的数字，则删除右上角的数字所在的列。这样经过一个循环，可以不断地缩小查找的范围。

同理，从左下角开始查找也可得到正确的解。

时间复杂度为$O(m*n)$，空间复杂度为$O(1)$。m和n分别为二维数组的长和宽。

```java
// 从右上角开始查找
public boolean findNumberIn2DArray(int[][] matrix, int target) {
    if (matrix.length == 0)
        return false;
    int i = 0, j = matrix[0].length-1;
    while (i < matrix.length && j >= 0) {
        if (matrix[i][j] == target)
            return true;
        else if (matrix[i][j] > target)
            j--;
        else i++;
    }
    return false;
}
```

```java
// 从左下角开始查找
public boolean findNumberIn2DArray(int[][] matrix, int target) {
    if (matrix.length == 0)
        return false;
    int i = matrix.length-1, j = 0;
    while (i >= 0 && j < matrix[0].length) {
        if (matrix[i][j] == target)
            return true;
        else if (matrix[i][j] > target)
            i--;
        else j++;
    }
    return false;
}
```