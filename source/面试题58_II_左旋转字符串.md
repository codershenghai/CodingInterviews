# 题目描述

汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！

# 题解一

如果允许使用API，那这道题是很简单的。

```java
public String LeftRotateString(String str,int n) {
    if (str.length() < n)
        return "";
    StringBuilder sb = new StringBuilder(str);
    sb.append(sb.substring(0, n));
    sb.delete(0, n);
    return sb.toString();
}
```

# 题解二

但由于本题的核心是考察对于字符串翻转的灵活运用，所以上面使用API的解法就失去了其意义。受到上题翻转单词顺序的启发，我们可以将字符串分为两部分，前n个字母为一部分，剩下的字母为一部分。先单独翻转这两部分，然后再对整体字符串一起翻转。例如对于"abcdefg"，n为2。分别翻转"ab"和"cdefg"，得到bagfedc，然后再对整个字符串进行翻转即可得到"cdefgab"。

这个思路可用线性代数的矩阵表示为
$$
YX = (X^T Y^T)^T
$$

```java
public String LeftRotateString(String str,int n) {
    if (str.length() < n)
        return "";
    char[] chars = str.toCharArray();
    reverse(chars, 0, n-1);
    reverse(chars, n, chars.length-1);
    reverse(chars, 0, chars.length-1);

    // 字符数组转化为字符串
    StringBuilder sb = new StringBuilder();
    for (char c : chars)
        sb.append(c);
    return sb.toString();
}

private void reverse(char[] chars, int left, int right) {
    if (left > right)
        return;
    while (left < right) {
        char temp = chars[left];
        chars[left++] = chars[right];
        chars[right--] = temp;
    }
}
```