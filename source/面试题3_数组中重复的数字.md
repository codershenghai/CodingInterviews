# 题目描述

找出数组中重复的数字。

在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例：

```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

# 题解一

简单粗暴，将数组的数组排序，然后从头到尾扫描一遍数组。

时间复杂度为$O(nlogn)$，空间复杂度为$O(1)$。

```java
public int findRepeatNumber(int[] nums) {
    int duplicate = 0;
    Arrays.sort(nums);
    for (int left = 0, right = 1; right < nums.length; left++, right++) {
        if (nums[left] == nums[right]) {
            duplicate = nums[left];
        }
    }
    return duplicate;
}
```

# 题解二

利用集合中元素唯一的特性，遍历一遍链表，如果集合中存在当前这个数，则找到重复元素，否则将当前数添加到集合中。

时间复杂度为$O(n)$，空间复杂度为$O(n)$。

```java
public int findRepeatNumber(int[] nums) {
    int duplicate = 0;
    Set<Integer> hashSet = new HashSet<>();
    for (int num : nums) {
        if (hashSet.contains(num)) duplicate = num;
        else hashSet.add(num);
    }
    return duplicate;
}
```

# 题解三

由于数组里的所有数字都在0到n-1的范围内，可将数字的值与数组的下标对应，从而找到数组中重复的数字。这种方法的缺点是需要修改数组。

具体来说，从头到尾扫描这个数组，对于数组中的每一个数字n，比较数字n是不是等于它的下标。

- 如果是，则说明数字n已经正确归位。
- 如果不是，则将它跟以n下标的那个数字进行比较。
  - 如果相等，则找到重复数字；
  - 否则交换这两个数字（将数字n正确归位下标为n的位置）。


时间复杂度为$O(n)$，空间复杂度为$O(1)$。

```java
public int findRepeatNumber(int[] nums) {
    int duplicate = 0;
    for (int i = 0; i < nums.length; i++) {
        // 对于数组中的每一个数字，比较这个数字是不是等于它的下标。
        while (i != nums[i]) {
            // 将这个数字跟以这个数字为下标的那个数字进行比较。如果相等，则找到重复数字，跳出循环。
            if (nums[i] == nums[nums[i]]) {
                duplicate = nums[i];
                break;
            }
            // 否则交换，nums[i]nums[nums[i]]，将这个数字n正确归位下标为n的位置。
            else {
                int temp = nums[i];
                nums[i] = nums[temp];
                nums[temp] = temp;
            }
        }
    }
    return duplicate;
}
```

