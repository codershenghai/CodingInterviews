# 题目描述

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。  

示例 1：

```
输入：[3,4,5,1,2]
输出：1
```


示例 2：

```
输入：[2,2,2,0,1]
输出：0
```

# 题解

最直观的想法是遍历一遍数组找出最小数字，这样的时间复杂度是$O(n)$。

但这样没有利用到旋转数组的特性，这里我们使用二分查找的思想，使用左右指针分别指向数组的第一个元素和最后一个元素。然后找到中间的元素，如果中间元素位于前面的递增子数组，则将左指针指向中间元素，缩小搜索范围；如果中间元素位于后面的递增子数组，则将右指针指向中间元素，缩小搜索范围。当左右指针间隔为1时结束循环。但需要注意的是，当左右指针指向的元素和中间元素都相等时，这时候我们不知道是缩小前面的递增子数组还是后面的递增子数组，此时算法失效，遇到这种情况时只能使用顺序查找。

时间复杂度为$O(logn)$，空间复杂度为$O(1)$。

```java
public int minArray(int[] array) {
    if (array.length == 1)
        return array[0];
    int left = 0, right = array.length - 1;
    int mid = left;
    while (array[left] >= array[right]) {
        if (right - left == 1)
            return array[right];
        mid = (left + right) / 2;

        if (array[left] == array[mid] && array[right] == array[mid])
            return findMinOrder(array);
        if (array[right] < array[mid])
            left = mid;
        else right = mid;
    }
    return array[mid];
}

private int findMinOrder(int[] array) {
    int min = Integer.MAX_VALUE;
    for (int num : array)
        if (num < min)
            min = num;
    return min;
}
```