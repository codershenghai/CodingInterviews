# 题目描述

实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

示例 1:

```python
输入: 2.00000, 10
输出: 1024.00000
```


示例 2:

```python
输入: 2.10000, 3
输出: 9.26100
```


示例 3:

```python
输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
```

# 题解一

最直观的解法是将base连乘exponent次。这种方法需要考虑三种情况，即当exponent为0、整数和负数时的情况。

时间复杂度为$O(n)$，空间复杂度为$O(1)$。

```java
public double myPow(double base, int exponent) {
    double res = 1.0;
    if (exponent > 0) {
        for (int i = 0; i < exponent; i++) {
            res *= base;
        }
    } else if (exponent < 0) {
        for (int i = 0; i > exponent; i--) {
            res /= base;
        }
    }
    return res;
}
```

# 题解二

使用递归，递归终止条件是 exponent == 0，也要分成exponent是正数和负数的情况。

时间复杂度为O(n)，空间复杂度为O(1)。

```java
public double myPow(double base, int exponent) {
    if (exponent == 0)
        return 1.0;
    if (exponent < 0)
        return myPow(base, exponent+1) / base;
    return myPow(base, exponent-1) * base;
}
```

# 题解三

上面的递归方法时间复杂度是O(n)，假设exponent为100，那么就需要递归99次。但是如果已经求出了base的50次方，那么还需要再进行后面的50次递归吗？其实在base的50次方的基础上直接求平方就够了。

依照这个思路，在exponent已经是正负两种情况下，我们继续分情况讨论：

- 若n为偶数，$a^n = a^n/2 * a^n/2$
- 若n为奇数，$a^n=(a^{(n-1)} /2) * (a^{(n-1)}/2)) * a$

时间复杂度为$O(logn)$，空间复杂度为$O(1)$。

```java
public double myPow(double base, int exponent) {
    // 递归终止的条件
    boolean flag = exponent < 0; //flag用于标记exponent的正负
    if (base == 0 && flag)
        throw new RuntimeException();
    if (base == 1 || exponent == 1)
        return base;
    if ((base == -1 && exponent == Integer.MIN_VALUE) || exponent == 0)
    	return 1;
    if ((base == 0 && !flag) || exponent == Integer.MIN_VALUE)
        return 0;

    // 找返回值
    exponent = flag ? -exponent : exponent;
    double half = myPow(base, exponent >> 1);

    // 本级递归应该做什么
    if ((exponent & 1) == 1)
        return flag ? 1/(half*half*base) : half*half*base;
    else return flag ? 1/(half*half) : half*half;
}
```