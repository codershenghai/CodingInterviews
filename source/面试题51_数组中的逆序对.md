# 题目描述

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007

# 题解一

第一种方法直接一个暴力双重循环统计逆序对。

时间复杂度为O(n^2)，空间复杂度为O(1)。

```java
public int InversePairs(int[] array) {
    int count = 0;
    for (int i = 0; i < array.length; i++) {
        for (int j = i+1; j < array.length; j++) {
            if (array[i] > array[j])
                count++;
        }
    }
    return count;
}
```

# 题解二

第二种方法是用归并排序的思想，但是需要辅助数组。采用分治法，在divide过程中先将数组分隔成一个个小的子数组，然后统计出两个相邻子数组之间逆序对的数量，在统计逆序对的同时进行排序。剑指offer中的解答比较详尽，详细的过程分析还是建议把书找出来看。

时间复杂度为O(nlogn)，空间复杂度为O(n)。

```java
public int InversePairs(int[] array) {
    if (array.length == 0)
        return 0;
    int[] arrayHelper = new int[array.length];
    return InversePairsHelper(array, 0, array.length-1, arrayHelper);
}

private int InversePairsHelper(int[] array, int left, int right, int[] arrayHelper) {
    if (left >= right)
        return 0;
    int mid = (left + right) >> 1;

    // divide
    int leftCount = InversePairsHelper(array, left, mid, arrayHelper);
    int rightCount = InversePairsHelper(array, mid+1, right, arrayHelper);

    // merge
    int count = 0;
    int i = mid, j = right, t = right;
    while (i >= left && j > mid) {
        if (array[i] > array[j]) {
            count += j - mid;
            count = count<1000000007 ? count : count % 1000000007;
            arrayHelper[t--] = array[i--];
        } else arrayHelper[t--] = array[j--];
    }
    while (i >= left)
        arrayHelper[t--] = array[i--];
    while (j > mid)
        arrayHelper[t--] = array[j--];
    if (right-left+1 >= 0)
        System.arraycopy(arrayHelper, left, array, left, right-left+1);
    return (leftCount + rightCount + count) % 1000000007;
}
```