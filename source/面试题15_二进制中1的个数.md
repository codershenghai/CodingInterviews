# 题目描述

请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

示例 1：

```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```


示例 2：

```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```


示例 3：

```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

# 题解一

最直观的想法是将输入的数字不断与1做与运算，来判断数字的二进制形式中最低位是否为1，通过不断右移这个数来判断这个数的二进制中1的个数。但是这种算法不支持负数，对于一个负数，移位后的最高位永远都是1，如果一直做右移运算，那么这个数最终会变成0xFFFFFFFF，而不是0，从而陷入死循环。

为了改进这个缺点，我们可以不右移输入的数字，而是首先将输入的数字与1做与运算，判断数字的二进制形式中最低位是否为1。然后将1左移一位得到2，再和输入的数字做与运算，判断数字的二进制形式中的次低位是不是1......这样不断左移，就可以统计出输入的数字的二进制形式中1的个数。

这种解法循环的次数等于二进制整数的位数，如32位整数就需要循环32次。

```java
public int hammingWeight(int n) {
    int count = 0;
    int flag = 1;
    while (flag != 0) {
        if ((n&flag) != 0)
            count++;
        flag <<= 1;
    }
    return count;
}
```

# 题解二

对于Hamming Weight，还有另外一种技巧性的解法。我们需要知道一个结论：**把一个整数减去1，再和原整数做与运算，结果会将原整数最右边的1变成0**。

我们只需要不断循环这个操作，当原整数为0时停止，即可统计出原整数的二进制中1的个数。这种解法循环的次数等于二进制整数中1的个数，有几个1就只需要循环几次。

```java
public int hammingWeight(int n) {
    int count = 0;
    while (n != 0) {
        count++;
        n = (n - 1) & n; // 每次循环都将最右边的1变为0
    }
    return count;
}
```