# 题目描述

输入一棵二叉树，判断该二叉树是否是平衡二叉树。

# 题解一

**自顶向下**的解法。对每个节点首先求左右子树的深度之差，然后递归判断左右子树是否是平衡二叉树，如果左右子树深度之差小于2，并且左右子树都是平衡二叉树，则根节点也是平衡二叉树。

```java
public boolean IsBalanced_Solution(TreeNode root) {
    if (root == null)
        return true;
    boolean absDepthSatisfy = Math.abs(TreeDepth(root.left) - TreeDepth(root.right)) < 2;
    boolean leftIsBalanced = IsBalanced_Solution(root.left);
    boolean rightIsBalanced = IsBalanced_Solution(root.right);
    return absDepthSatisfy && leftIsBalanced && rightIsBalanced;
}

public int TreeDepth(TreeNode root) {
    if (root == null)
        return 0;
    return Math.max(TreeDepth(root.left), TreeDepth(root.right)) + 1;
}
```
# 题解二

题解一的解法很简洁，但是时间复杂度较高，在上层节点的时候，下层节点可能会被重复遍历，节点的高度会被计算多次。

因此可以考虑**自下向上**的解法，转化为求树的深度。如果子树是平衡二叉树，则返回子树的深度；否则停止遍历，这样每个节点最多只访问一次。

```java
public boolean IsBalanced_Solution(TreeNode root) {
    return GetDepth(root) != -1;
}

private int GetDepth(TreeNode node) {
    if (node == null)
        return 0;
    int left = GetDepth(node.left);
    if (left == -1) return -1; // 剪枝
    int right = GetDepth(node.right);
    if (right == -1) return -1; // 剪枝
    return Math.abs(left-right)>1 ? -1 : Math.max(left, right)+1;
}
```