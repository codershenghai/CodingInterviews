# 题目描述

给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。

# 题解一

利用队列的性质，可将滑动窗口看成一个队列。当窗口滑动时，前面的数字被删除，后面的数字被加入，这就符合队列先进先出的性质。

```java
public ArrayList<Integer> maxInWindows(int[] nums, int size) {
    ArrayList<Integer> res = new ArrayList<>();
    if (size == 0 || size > nums.length)
        return res;
    Queue<Integer> queue = new LinkedList<>();
    for (int num : nums) {
        // 当队列的大小等于size时，计算最大值
        if (queue.size() == size) {
            int max = Integer.MIN_VALUE;
            for (int i : queue)
                if (i > max) max = i;
            res.add(max);
            queue.poll();
        }
        queue.offer(num);
    }
    int max = Integer.MIN_VALUE;
    for (int i : queue)
        if (i > max) max = i;
    res.add(max);
    return res;
}
```

# 题解二

但是题解一的解法需要对于每一个滑动窗口都遍历一遍，所消耗的时间是比较大的。

我们可以使用双端队列来记录数组的下标，队列头保存当前滑动窗口最大值的下标。当窗口每滑动一次：

1. 对于新增加的值，从队尾开始比较，将队列中比它小的值丢弃。
2. 如果队首元素超出当前滑动窗口，则出队。
3. 将新增加的数组下标入队。
4. 将当前滑动窗口的最大值加入res中。

```java
public ArrayList<Integer> maxInWindows2(int[] nums, int size) {
    ArrayList<Integer> res = new ArrayList<>();
    if (size == 0 || size > nums.length)
        return res;
    LinkedList<Integer> queueMax = new LinkedList<>();
    for (int i = 0; i < nums.length; i++) {
        // 1.对于新增加的值，从队尾开始比较，将队列中比它小的值丢弃。
        while (!queueMax.isEmpty() && nums[queueMax.peekLast()] < nums[i])
            queueMax.pollLast();
        // 2.如果队首元素超出当前滑动窗口，则出队。
        if (!queueMax.isEmpty() && i - queueMax.peekFirst() == size)
            queueMax.pollFirst();
        // 3.将新增加的数组下标入队。
        queueMax.addLast(i);
        // 4.将当前滑动窗口的最大值加入到res中
        if (!queueMax.isEmpty() && i >= size-1)
            res.add(nums[queueMax.peekFirst()]);
    }
    return res;
}
```