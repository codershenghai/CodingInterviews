# 题目描述

输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的

# 题解一

第一种是暴力法，即固定一个数字，然后判断其余的数字与它的和是否等于s。

时间复杂度为O(n^2)，空间复杂度为O(1)。

```java
public ArrayList<Integer> FindNumbersWithSum(int[] array, int sum) {
    int num1 = Integer.MIN_VALUE, num2 = Integer.MIN_VALUE, minProduct = Integer.MAX_VALUE;
    for (int i = 0; i < array.length; i++) {
        for (int j = i+1; j < array.length; j++) {
            if (array[i]+array[j] == sum && array[i]*array[j] < minProduct) {
                num1 = array[i];
                num2 = array[j];
                minProduct = num1 * num2;
            }
        }
    }
    ArrayList<Integer> res = new ArrayList<>();
    if (num1 > Integer.MIN_VALUE && num2 > Integer.MIN_VALUE) {
        res.add(num1);
        res.add(num2);
    }
    return res;
}
```

# 题解二

遍历一遍数组，建立一个集合用于存储已遍历的数字。使用num1和num2记录找到的结果，使用minProduct记录最小乘积。如果sum减去当前数字的值不在集合中，就将当前数字存入集合中；如果对应值在集合中，那么就判断当前两个数的乘积是否是乘积最小的，若是，则更新num1和num2。遍历结束后将num1和num2存入数组即可。

时间复杂度为O(n)，空间复杂度为O(n)。

```java
public ArrayList<Integer> FindNumbersWithSum(int[] array, int sum) {
    HashSet<Integer> set = new HashSet<>();
    ArrayList<Integer> res = new ArrayList<>();
    int num1 = Integer.MIN_VALUE, num2 = Integer.MIN_VALUE, minProduct = Integer.MAX_VALUE;
    for (int num : array) {
        if (set.contains(sum - num)) {
            if ((sum-num) * num < minProduct) {
                num1 = sum - num;
                num2 = num;
                minProduct = num1 * num2;
            }
        } else set.add(num);
    }
    if (num1 > Integer.MIN_VALUE && num2 > Integer.MIN_VALUE) {
        res.add(num1);
        res.add(num2);
    }
    return res;
}
```

# 题解三

使用双指针，由于数组已经排序，所以第一次找到的和为s的两个数字必然是乘积最小的。

- 如果left+right的值小于sum，说明要找的数字在right左边，right--；
- 如果left+right的值大于sum，说明要找的数字在left右边，left++；
- 如果left+right的值等于sum，则找到结果。

时间复杂度为O(n)，空间复杂度为O(1)。

```java
public ArrayList<Integer> FindNumbersWithSum(int[] array, int sum) {
    int left = 0, right = array.length-1;
    ArrayList<Integer> res = new ArrayList<>();
    while (left < right) {
        if (array[left] + array[right] < sum)
            left++;
        else if (array[left] + array[right] > sum)
            right--;
        else {
            res.add(array[left]);
            res.add(array[right]);
            break;
        }
    }
    return res;
}
```