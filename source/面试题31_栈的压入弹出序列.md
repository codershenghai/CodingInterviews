# 题目描述

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

示例 1：

```
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
```


示例 2：

```
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```



# 题解

借用辅助栈，遍历一遍压栈序列，将pushA中的元素放入栈中，判断栈顶元素是否和出栈序列中对应的元素相等，若不相等继续压栈，相等则出栈。

循环完毕后，即压栈序列中的所有元素全部压栈完毕。如果辅助栈为空，说明全部出栈完毕，返回true，否则返回false。

下面给出两种实现方法：

```java
public boolean validateStackSequences(int[] pushA,int[] popA) {
    if (pushA.length != popA.length)
        return false;

    int index1 = 0, index2 = 0;
    Stack<Integer> stack = new Stack<>();

    // 当栈不为空或pushA中元素没有全部压栈时循环
    while (!stack.empty() || index1 < pushA.length){

        // 如果栈为空，且pushA中的元素没有全部压栈，那么压栈
        if (stack.empty())
            stack.push(pushA[index1++]);

        // 若栈顶元素和popA中对应元素相等，栈顶元素出栈，并且index2++
        if (stack.peek() == popA[index2]) {
            stack.pop();
            index2++;
        }

        // 若栈顶元素和popA中对应元素不相等（注意：由于上一个if语句的pop可能会使栈为空，因此要确保栈不为空）
        // 继续判断，若pushA中元素全部压栈完毕，直接返回false
        // 若pushA中元素没有全部压栈，继续压栈，并且index1++
        if (!stack.empty() && stack.peek() != popA[index2]) {
            if (index1 < pushA.length)
                stack.push(pushA[index1++]);
            else return false;
        }
    }
    return stack.empty();
}
```

```java
public boolean validateStackSequences(int[] pushA,int[] popA) {
    if (pushA.length != popA.length)
        return false;

    int indexPop = 0;
    Stack<Integer> stack = new Stack<>();

    // 遍历压栈序列
    for (int num : pushA) {
        stack.push(num);
        // 每次压栈之后都试试是否能够出栈
        while (!stack.empty() && stack.peek() == popA[indexPop]) {
            stack.pop();
            indexPop++;
        }
    }
    return stack.empty();
}
```