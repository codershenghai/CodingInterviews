# 题目描述

请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

示例1：

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

示例2：

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

示例3：

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```


# 题解一

使用哈希表保存原链表和复制后链表的指针。

1. 第一个遍历将原链表的next指针复制一遍，同时保存对应的指针（确保原链表中的每一个节点都能在复制后链表中找到）。
2. 第二个遍历将原链表的random指针复制一遍（从哈希表中取对应节点）。

时间复杂度为O(n)，空间复杂度为O(n)。

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
public Node copyRandomList(Node head) {
    if (head == null)
        return null;
    Node headClone = new Node(head.val);
    HashMap<Node, Node> map = new HashMap<>();
    map.put(head, headClone);

    // 第一个遍历复制next指针
    Node p = head.next;
    Node pClone = headClone;
    while (p != null) {
        pClone.next = new Node(p.val);
        pClone = pClone.next;
        map.put(p, pClone);
        p = p.next;
    }

    // 第二个遍历复制random指针
    p = head;
    pClone = headClone;
    while (p != null) {
        if (p.random != null)
            pClone.random = map.get(p.random);
        p = p.next;
        pClone = pClone.next;
    }
    return headClone;
}
```

# 题解二

1. 在原链表的每个节点后都添加一个节点作为复制后的节点。
2. 给复制后的节点添加random指针。
3. 把第二步得到的链表拆分成两个链表。

时间复杂度为O(n)，空间复杂度为O(1)。

```java
public Node copyRandomList(Node head) {
    if (head == null)
        return null;

    // 1.在原链表的每个节点后都添加一个节点作为复制后的节点。
    Node p = head;
    Node r;
    while (p != null) {
        r = new Node(p.val);
        r.next = p.next;
        p.next = r;
        p = r.next;
    }

    // 2.添加random指针。
    p = head;
    while (p != null) {
        if (p.random != null)
            p.next.random = p.random.next;
        p = p.next.next;
    }

    // 3.拆分两个链表。
    p = head;
    r = head.next;
    Node headClone = r;
    while (p != null) {
        p.next = p.next.next;
        if (r != null && r.next != null)
            r.next = r.next.next;
        p = p.next;
        r = r.next;
    }
    return headClone;
}
```

