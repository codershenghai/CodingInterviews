# 题目描述

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
给定的树 A:

```python
     3
    / \
   4   5
  / \
 1   2
```


给定的树 B：

```python
   4
  /
 1
```

返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

# 题解

判断一个树B是不是另一个树A的子结构，首先需要在树A中找到和树B的根节点一样的节点，然后再判断以这个节点为根节点的子树是不是和树B相同。

对于在树A中寻找与树B的根节点的值相同的节点，可以用先序遍历的方法或是层次遍历的方法实现，这里用先序遍历的方法实现。如果找到了这个节点，那么需要判断以这个节点为根节点的子树是否和树B相同，同样可以用先序遍历的方法实现。

```java
public boolean isSubStructure(TreeNode root1, TreeNode root2) {
    boolean flag = false;
    if (root1 == null || root2 == null)
        return false;
    if (root1.val == root2.val)
        flag = DoesTree1HaveTree2(root1, root2);
    if (!flag)
        flag = isSubStructure(root1.left, root2);
    if (!flag)
        flag = isSubStructure(root1.right, root2);
    return flag;
}

private boolean DoesTree1HaveTree2(TreeNode node1, TreeNode node2) {
    // 如果node2遍历完了，说明之前的都能对应，返回true
    if (node2 == null)
        return true;
    // 如果node2没有遍历完，但node1却遍历完了，返回false；或者当前根节点没有对应上，也返回false
    if (node1 == null || node1.val != node2.val)
        return false;
    // 进入node1的子节点中进行递归
    return DoesTree1HaveTree2(node1.left, node2.left) && DoesTree1HaveTree2(node1.right, node2.right);
}
```