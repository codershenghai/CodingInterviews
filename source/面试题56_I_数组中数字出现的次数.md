# 题目描述

一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

# 题解一

先将数组排序，然后再找出现一次的数字是比较简单的。

时间复杂度为O(nlogn)，空间复杂度为O(1)。

# 题解二

还有一种思想是以空间换时间，使用一个哈希表来记录数组中每个数字出现的次数，最终可以得到两个只出现一次的数字。

时间复杂度为O(n)，空间复杂度为O(n)。

# 题解三

如果将这道题改为数组中只有一个数字只出现一次，那么问题就简单了。我们可以利用异或运算（相同为0，不同为1）的性质：

1. 任何一个数字异或它自己都等于0。
2. 异或运算具有交换律。

因此，如果我们依次遍历异或数组中的每个数字，那么最终出现的结果就是那个只出现一次的数字。

由于这道题中有两个数字只出现一次，所以会复杂一点，但是我们依旧可以将它化解为一个数字的情形。只要将原数组拆成两个数组，每个数组都包含一个只出现一次的数字即可。

我们还是从头到尾一次遍历异或数组中的每个数字，最终会得到那两个只出现一次的数字的异或结果。而这个结果的二进制表示中至少有一位为1，假设我们在结果中找到第一个为1的位的位置，那么就可以对于所有数字按照这个位是否为1划分为两部分。因为那两个只出现一次的数在这个位上异或结果为1（对于异或，相同为0，不同为1），说明这两个数在这个位上是不一样的。使用这个判断条件，可以把这两个数分开。至于那些相同的数字，它们两两配对，一定会分到同一个数组中，这没什么好说的。

得到两个数组之后，我们就将这个问题转化为求数组中一个数字出现一次的问题了。

时间复杂度为O(n)，空间复杂度为O(1)。

```java
public void FindNumsAppearOnce(int[] array, int[] num1, int[] num2) {
    if (array.length == 0)
        return;
    // 得到两个只出现一次的数字的异或结果
    int resOR = 0;
    for (int num : array)
        resOR ^= num;

    // 计算第一个为1的位的位置，据此将原数组划分为两个数组
    String resORString = Integer.toBinaryString(resOR);
    int index = 0;
    for (int i = resORString.length()-1; i >= 0; i--) {
        if (resORString.charAt(i) == '1')
            break;
        else index++;
    }

    // 划分数组
    ArrayList<Integer> list1 = new ArrayList<>();
    ArrayList<Integer> list2 = new ArrayList<>();
    for (int num : array) {
        String numString = Integer.toBinaryString(num);
        int numIndex = numString.length() - 1 - index;
        if (numIndex >= 0 && numString.charAt(numIndex) == '1')
            list1.add(num);
        else list2.add(num);
    }

    // 寻找数组中唯一的那个数字
    num1[0] = FindNum(list1);
    num2[0] = FindNum(list2);
}

private int FindNum(ArrayList<Integer> list) {
    int res = 0;
    for (int num : list)
        res ^= num;
    return res;
}
```