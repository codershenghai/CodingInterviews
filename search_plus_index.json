{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 这里是《剑指Offer》第二版的使用Java实现的题解，仅供参考~ 我的博客主页：http://zhangshenghai.com 我的邮箱：shenghaishxt@gmail.com 如果有错误的地方欢迎指出~ "},"面试题3_数组中重复的数字.html":{"url":"面试题3_数组中重复的数字.html","title":"面试题3：数组中重复的数字","keywords":"","body":"题目描述 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例： 输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 题解一 简单粗暴，将数组的数组排序，然后从头到尾扫描一遍数组。 时间复杂度为$O(nlogn)$，空间复杂度为$O(1)$。 public int findRepeatNumber(int[] nums) { int duplicate = 0; Arrays.sort(nums); for (int left = 0, right = 1; right 题解二 利用集合中元素唯一的特性，遍历一遍链表，如果集合中存在当前这个数，则找到重复元素，否则将当前数添加到集合中。 时间复杂度为$O(n)$，空间复杂度为$O(n)$。 public int findRepeatNumber(int[] nums) { int duplicate = 0; Set hashSet = new HashSet<>(); for (int num : nums) { if (hashSet.contains(num)) duplicate = num; else hashSet.add(num); } return duplicate; } 题解三 由于数组里的所有数字都在0到n-1的范围内，可将数字的值与数组的下标对应，从而找到数组中重复的数字。这种方法的缺点是需要修改数组。 具体来说，从头到尾扫描这个数组，对于数组中的每一个数字n，比较数字n是不是等于它的下标。 如果是，则说明数字n已经正确归位。 如果不是，则将它跟以n下标的那个数字进行比较。 如果相等，则找到重复数字； 否则交换这两个数字（将数字n正确归位下标为n的位置）。 时间复杂度为$O(n)$，空间复杂度为$O(1)$。 public int findRepeatNumber(int[] nums) { int duplicate = 0; for (int i = 0; i "},"面试题4_二维数组中的查找.html":{"url":"面试题4_二维数组中的查找.html","title":"面试题4：二维数组中的查找","keywords":"","body":"题目描述 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例： 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 题解 二维数组是矩形的，有四个边角。很自然的想到，如果要开始查找，从哪个边角开始比较好呢？ 如果从左上角开始查找，数字向右和向下都是递增的，我们不知道应该往哪里走，无法缩小查找的范围。同理，从右下角开始也是一样的，数字向左和向上都是递减的，也无法缩小查找的范围。 如果从右上角开始查找，数字向左递减向下递增，我们可以将要查找的数字和右上角这个数字进行对比，若两者相等，则查找结束。如果要查找的数字大于右上角的数字，则删除右上角的数字所在的行。如果要查找的数字小于右上角的数字，则删除右上角的数字所在的列。这样经过一个循环，可以不断地缩小查找的范围。 同理，从左下角开始查找也可得到正确的解。 时间复杂度为$O(m*n)$，空间复杂度为$O(1)$。m和n分别为二维数组的长和宽。 // 从右上角开始查找 public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix.length == 0) return false; int i = 0, j = matrix[0].length-1; while (i = 0) { if (matrix[i][j] == target) return true; else if (matrix[i][j] > target) j--; else i++; } return false; } // 从左下角开始查找 public boolean findNumberIn2DArray(int[][] matrix, int target) { if (matrix.length == 0) return false; int i = matrix.length-1, j = 0; while (i >= 0 && j target) i--; else j++; } return false; } "},"面试题5_替换空格.html":{"url":"面试题5_替换空格.html","title":"面试题5：替换空格","keywords":"","body":"题目描述 请实现一个函数，把字符串 s 中的每个空格替换成\"%20\"。 示例： 输入：s = \"We are happy.\" 输出：\"We%20are%20happy.\" 题解一 从前往后插入。从头到尾扫描字符串，每次碰到空格字符的时候进行替换。 时间复杂度为$O(n^2)$，空间复杂度为$O(1)$。 public String replaceSpace(String s) { StringBuilder builder = new StringBuilder(s); for (int i = 0; i 题解二 从后往前插入。先遍历一次字符串统计空格数，计算出替换空格后字符串的总长度。给字符串分配新的长度，然后从字符串的最后开始替换。 时间复杂度为$O(n)$，空间复杂度为$O(1)$。 public String replaceSpace(String s) { StringBuilder builder = new StringBuilder(s); // 先遍历一次字符串统计空格数 int spaceNum = 0, oldLength = builder.length(); for (int i = 0; i "},"面试题6_从尾到头打印链表.html":{"url":"面试题6_从尾到头打印链表.html","title":"面试题6：从尾到头打印链表","keywords":"","body":"题目描述 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例： 输入：head = [1,3,2] 输出：[2,3,1] 题解一 利用栈先入后出的特性，遍历链表，将链表所有节点存入栈中，再将所有节点全部出栈，可将链表倒置。 public int[] reversePrint(ListNode head) { Stack stack = new Stack<>(); while (head != null) { stack.add(head.val); head = head.next; } int[] list = new int[stack.size()]; for (int i = 0; i 题解二 递归本质就是一个栈结构，很自然地想到递归。首先列出递归终止的条件，当访问到链表尾时传回一个空数组；然后找返回值；最后是写本级递归应该做的内容，将本级节点中的值添加到传回的数组中。 public int[] reversePrint(ListNode head) { ArrayList list = reversePrintHelper(head); int[] res = new int[list.size()]; for (int i = 0; i reversePrintHelper(ListNode listNode) { // 1.递归终止的条件 if (listNode == null) return new ArrayList<>(); // 2.找返回值 ArrayList list = reversePrintHelper(listNode.next); // 3.本级递归应该做什么 list.add(listNode.val); return list; } "},"面试题7_重建二叉树.html":{"url":"面试题7_重建二叉树.html","title":"面试题7：重建二叉树","keywords":"","body":"题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 例如，给出： 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 3 / \\ 9 20 / \\ 15 7 题解 根据前序遍历序列的第一个值，将中序遍历的序列分成两部分。左边的子序列就是根节点的左子树中序遍历的结果，右边的子序列就是根节点的右子树中序遍历的结果。然后继续对两个子树递归求解即可。 为了方便递归，使用一个辅助函数，传入子序列开始的下标和结束的下标。这道题比较麻烦的是下标的处理，为此，记录左子树序列的长度，方便下标的计算。 public TreeNode buildTree(int[] pre, int[] in) { return buildTreeHelper(pre, 0, pre.length-1, in, 0, in.length-1); } private TreeNode buildTreeHelper(int[] pre, int preStart, int preEnd, int[] in, int inStart, int inEnd) { if (preStart > preEnd || inStart > inEnd) return null; TreeNode root = new TreeNode(pre[preStart]); for (int i = inStart; i "},"面试题8_二叉树的下一个节点.html":{"url":"面试题8_二叉树的下一个节点.html","title":"面试题8：二叉树的下一个节点","keywords":"","body":"题目描述 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 题解 这道题可以分三种情况讨论： pNode有右孩子，那么下一个节点是其右孩子的最左子节点。 pNode没有右孩子且是其父节点的左孩子，那么下一个节点是其父节点。 pNode没有右孩子且是其父节点的右孩子。则沿其父节点指针一直向上遍历，直到找到一个是它父节点的左子节点的节点，如果这样的节点存在，那么这个节点的父节点就是我们要找的节点。如果这样的节点不存在，根节点就是我们要找的节点。 public TreeLinkNode GetNext(TreeLinkNode pNode) { if (pNode == null) return null; TreeLinkNode pNext = null; if (pNode.right != null) { TreeLinkNode p = pNode.right; while (p.left != null) p = p.left; pNext = p; } else if (pNode.next != null){ TreeLinkNode pCurrent = pNode; TreeLinkNode pParent = pNode.next; while (pParent != null && pCurrent == pParent.right) { pCurrent = pParent; pParent = pParent.next; } pNext = pParent; } return pNext; } "},"面试题9_用两个栈实现队列.html":{"url":"面试题9_用两个栈实现队列.html","title":"面试题9：用两个栈实现队列","keywords":"","body":"题目描述 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 输入： [\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[3],[],[]] 输出：[null,null,3,-1] 示例 2： 输入： [\"CQueue\",\"deleteHead\",\"appendTail\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[],[5],[2],[],[]] 输出：[null,-1,null,null,5,2] 题解 初始化两个栈，一个栈用于push，一个栈用于pop。 在模拟队列中入队时，直接在stack1中添加元素即可。 在模拟队列中出队时，首先判断stack2是否为空，当stack2不为空时，栈顶元素是最先进入队列的元素，直接将栈顶元素出栈。当stack2为空时，则将stack1中的元素依次出栈添加到stack2中，这与最先进入stack1的元素就会在stack2的栈顶；如果stack1也为空，则队列为空，直接返回-1。 class CQueue { Stack stack1; Stack stack2; public CQueue() { stack1 = new Stack<>(); stack2 = new Stack<>(); } public void appendTail(int node) { stack1.push(node); } public int deleteHead() { if (stack2.empty()) { if (stack1.empty()) return -1; while (!stack1.empty()) stack2.push(stack1.pop()); } return stack2.pop(); } } "},"面试题10_I_斐波那契数列.html":{"url":"面试题10_I_斐波那契数列.html","title":"面试题10-I：斐波那契数列","keywords":"","body":"题目描述 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N > 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2 输出：1 示例 2： 输入：n = 5 输出：5 题解一 最简单的解法就是递归了。 public int fib(int n) { if (n == 0 || n == 1) return n; return (Fibonacci1(n-1) + Fibonacci1(n-2)) % 1000000007; } 题解二 使用动态规划的思想，从下往上计算，将已经得到的结果保存下来。状态转移方程为： $$ dp[n] = dp[n-1] + dp[n-2] $$ public int fib(int n) { if (n == 0 || n == 1) return n; int[] dp = new int[n+1]; dp[0] = 0; dp[1] = 1; for (int i = 2; i "},"面试题10_II_青蛙跳台阶问题.html":{"url":"面试题10_II_青蛙跳台阶问题.html","title":"面试题10-II：青蛙跳台阶问题","keywords":"","body":"题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2 输出：2 示例 2： 输入：n = 7 输出：21 题解 使用动态规划的思想，当台阶只有1级时，显然只有1种跳法；当台阶有2两级时，有2种跳法（分两次跳或者一次直接跳上）。因此当台阶有i级时，有可能是从第i-1级跳上来，也可能是从第i-2级跳上来。故有状态转移方程： $$ dp[i] = dp[i-1] + dp[i-2] $$ public int numWays(int target) { if (target == 0) return 1; if (target "},"面试题10_III_变态青蛙跳台阶问题.html":{"url":"面试题10_III_变态青蛙跳台阶问题.html","title":"面试题10-III：变态青蛙跳台阶问题","keywords":"","body":"题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 题解一 使用动态规划的思想，当台阶只有1级时，显然只有1种跳法；当台阶有2两级时，有2种跳法（分两次跳或者一次直接跳上）。当台阶有i级时，有可能是从第i-1级跳上来，也可能是从第i-2级跳上来，也可能是从第i-1级跳上来......故有状态转移方程： $$ dp[i] = dp[0] + dp[1] + ... + dp[i-1] $$ public int JumpFloorII(int target) { int[] dp = new int[target+1]; dp[0] = 1; // dp[i] = dp[0] + dp[1] + ... + dp[i-1] for (int i = 1; i 题解二 由于最后一个台阶必须存在，且青蛙可以一步登上第n级台阶，那么前n-1个台阶可以任意选择是否存在。假设跳上第n级台阶共有JumpFloorII(n)个选择，那么JumpFloorII(n) = 2 * JumpFloorII(n-1)。 public int JumpFloorII(int target) { if (target == 1) return 1; return JumpFloorII(target-1) * 2; } "},"面试题10_IV_矩形覆盖.html":{"url":"面试题10_IV_矩形覆盖.html","title":"面试题10-IV：矩形覆盖","keywords":"","body":"题目描述 我们可以用2 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？ 比如n=3时，2 * 3的矩形块有3种覆盖方法。 题解一 当n=1时，只有一种覆盖方法；当n=2时，有两种覆盖方法，即可以两块小矩形横着并排放也可以竖着并排放。 对于n块矩形，完成最后的搭建只能是搭上一块竖着的小矩形或是搭上两块横着的小矩形。可得到递推方程： $$ RectCover(n) = RectCover(n-1) + RectCover(n-2) $$ public int RectCover(int target) { if (target 题解二 这里的动态规划解法对上面的递归解法加以改进，将递归的自上而下改为动态规划的自下而上地进行计算，将计算的结果保存进数组中，其余分析过程同题解一。状态转移方程为： $$ dp[i] = dp[i-1] + dp[i-2] $$ public int RectCover(int target) { if (target "},"面试题11_旋转数组的最小数字.html":{"url":"面试题11_旋转数组的最小数字.html","title":"面试题11：旋转数组的最小数字","keywords":"","body":"题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1： 输入：[3,4,5,1,2] 输出：1 示例 2： 输入：[2,2,2,0,1] 输出：0 题解 最直观的想法是遍历一遍数组找出最小数字，这样的时间复杂度是$O(n)$。 但这样没有利用到旋转数组的特性，这里我们使用二分查找的思想，使用左右指针分别指向数组的第一个元素和最后一个元素。然后找到中间的元素，如果中间元素位于前面的递增子数组，则将左指针指向中间元素，缩小搜索范围；如果中间元素位于后面的递增子数组，则将右指针指向中间元素，缩小搜索范围。当左右指针间隔为1时结束循环。但需要注意的是，当左右指针指向的元素和中间元素都相等时，这时候我们不知道是缩小前面的递增子数组还是后面的递增子数组，此时算法失效，遇到这种情况时只能使用顺序查找。 时间复杂度为$O(logn)$，空间复杂度为$O(1)$。 public int minArray(int[] array) { if (array.length == 1) return array[0]; int left = 0, right = array.length - 1; int mid = left; while (array[left] >= array[right]) { if (right - left == 1) return array[right]; mid = (left + right) / 2; if (array[left] == array[mid] && array[right] == array[mid]) return findMinOrder(array); if (array[right] "},"面试题12_矩阵中的路径.html":{"url":"面试题12_矩阵中的路径.html","title":"面试题12：矩阵中的路径","keywords":"","body":"题目描述 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。 [[\"a\",\"b\",\"c\",\"e\"], [\"s\",\"f\",\"c\",\"s\"], [\"a\",\"d\",\"e\",\"e\"]] 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 示例 1： 输入：board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\" 输出：true 示例 2： 输入：board = [[\"a\",\"b\"],[\"c\",\"d\"]], word = \"abcd\" 输出：false 题解 本题使用回溯法的思想，回溯法实际上是深度优先遍历DFS。对于这个二维数组，遍历每一个格子作为路径的起点进行回溯。由于路径不能重复进入格子，因此还需要一个flag矩阵来标记当前路径是否已经进入格子。 public boolean exist(char[][] matrix, String str) { int m = matrix.length, n = matrix[0].length; boolean[][] flag = new boolean[m][n]; for (int i = 0; i =m || j>=n || matrix[i][j]!=str.charAt(k) || flag[i][j]) return false; if (k == str.length()-1) return true; // 回溯 flag[i][j] = true; if (backTrack(matrix, i-1, j, flag, str, k+1) || backTrack(matrix, i+1, j, flag, str, k+1) || backTrack(matrix, i, j-1, flag, str, k+1) || backTrack(matrix, i, j+1, flag, str, k+1)) return true; flag[i][j] = false; return false; } "},"面试题13_机器人的运动范围.html":{"url":"面试题13_机器人的运动范围.html","title":"面试题13：机器人的运动范围","keywords":"","body":"题目描述 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 示例 1： 输入：m = 2, n = 3, k = 1 输出：3 示例 2： 输入：m = 3, n = 1, k = 0 输出：1 题解 使用回溯法，将机器人能够成功访问的位置标记为true，防止重复访问，然后在当前位置往四个方向尝试。还需要写一个获取数位之和的函数，用于处理递归终止条件。 public int movingCount(int rows, int cols, int threshold) { boolean[] flag = new boolean[rows * cols]; return backTrack(threshold, rows, cols, 0, 0, flag); } private int backTrack(int threshold, int rows, int cols, int i, int j, boolean[] flag) { // 递归终止条件 int index = i * cols + j; if (i=rows || j>=cols || getDigitSum(i)+getDigitSum(j) > threshold || flag[index]) return 0; flag[index] = true; // 回溯 return backTrack(threshold, rows, cols, i-1, j, flag) + backTrack(threshold, rows, cols, i+1, j, flag) + backTrack(threshold, rows, cols, i, j-1, flag) + backTrack(threshold, rows, cols, i, j+1, flag) + 1; } private int getDigitSum(int num) { int digitSum = 0; while (num != 0) { digitSum += num % 10; num /= 10; } return digitSum; } "},"面试题14_剪绳子.html":{"url":"面试题14_剪绳子.html","title":"面试题14：剪绳子","keywords":"","body":"题目描述 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 $k[0],k[1]...k[m] $。请问 $k[0]k[1]...*k[m] $可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例 1： 输入: 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1 示例 2: 输入: 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 题解一 使用动态规划的方法，将$dp[i]$定义为长度为$i$的绳子可能的最大乘积，根据题意可得到状态转移方程： $$ dp[i] = max(dp[j] * dp[i-j]),　0 $$ 时间复杂度为$O(n^2)$，空间复杂度为$O(n)$。 public int cuttingRope(int target) { if (target == 2) return 1; if (target == 3) return 2; int[] dp = new int[target+1]; dp[2] = 2; dp[3] = 3; for (int i = 4; i 题解二 使用贪心策略，在绳子总长大于5时，尽可能多的剪下长度为3的绳子（很明显，此时3(n-3) >= 2(n-2)）；当绳子总长为4时，将绳子剪成两段长度为2的绳子。 时间复杂度为$O(1)$，空间复杂度为$O(1)$。 public int cuttingRope(int target) { if (target == 2) return 1; if (target == 3) return 2; int lengthOf2, lengthOf3; if (target % 3 == 0) { lengthOf2 = 0; lengthOf3 = target / 3; } else if (target % 3 == 1) { lengthOf2 = 2; lengthOf3 = target / 3 - 1; } else { lengthOf2 = 1; lengthOf3 = target / 3; } return (int) (Math.pow(3, lengthOf3) * Math.pow(2, lengthOf2)); } "},"面试题15_二进制中1的个数.html":{"url":"面试题15_二进制中1的个数.html","title":"面试题15：二进制中1的个数","keywords":"","body":"题目描述 请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。 示例 1： 输入：00000000000000000000000000001011 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2： 输入：00000000000000000000000010000000 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3： 输入：11111111111111111111111111111101 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 题解一 最直观的想法是将输入的数字不断与1做与运算，来判断数字的二进制形式中最低位是否为1，通过不断右移这个数来判断这个数的二进制中1的个数。但是这种算法不支持负数，对于一个负数，移位后的最高位永远都是1，如果一直做右移运算，那么这个数最终会变成0xFFFFFFFF，而不是0，从而陷入死循环。 为了改进这个缺点，我们可以不右移输入的数字，而是首先将输入的数字与1做与运算，判断数字的二进制形式中最低位是否为1。然后将1左移一位得到2，再和输入的数字做与运算，判断数字的二进制形式中的次低位是不是1......这样不断左移，就可以统计出输入的数字的二进制形式中1的个数。 这种解法循环的次数等于二进制整数的位数，如32位整数就需要循环32次。 public int hammingWeight(int n) { int count = 0; int flag = 1; while (flag != 0) { if ((n&flag) != 0) count++; flag 题解二 对于Hamming Weight，还有另外一种技巧性的解法。我们需要知道一个结论：把一个整数减去1，再和原整数做与运算，结果会将原整数最右边的1变成0。 我们只需要不断循环这个操作，当原整数为0时停止，即可统计出原整数的二进制中1的个数。这种解法循环的次数等于二进制整数中1的个数，有几个1就只需要循环几次。 public int hammingWeight(int n) { int count = 0; while (n != 0) { count++; n = (n - 1) & n; // 每次循环都将最右边的1变为0 } return count; } "},"面试题16_数值的整数次方.html":{"url":"面试题16_数值的整数次方.html","title":"面试题16：数值的整数次方","keywords":"","body":"题目描述 实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。 示例 1: 输入: 2.00000, 10 输出: 1024.00000 示例 2: 输入: 2.10000, 3 输出: 9.26100 示例 3: 输入: 2.00000, -2 输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25 题解一 最直观的解法是将base连乘exponent次。这种方法需要考虑三种情况，即当exponent为0、整数和负数时的情况。 时间复杂度为$O(n)$，空间复杂度为$O(1)$。 public double myPow(double base, int exponent) { double res = 1.0; if (exponent > 0) { for (int i = 0; i exponent; i--) { res /= base; } } return res; } 题解二 使用递归，递归终止条件是 exponent == 0，也要分成exponent是正数和负数的情况。 时间复杂度为O(n)，空间复杂度为O(1)。 public double myPow(double base, int exponent) { if (exponent == 0) return 1.0; if (exponent 题解三 上面的递归方法时间复杂度是O(n)，假设exponent为100，那么就需要递归99次。但是如果已经求出了base的50次方，那么还需要再进行后面的50次递归吗？其实在base的50次方的基础上直接求平方就够了。 依照这个思路，在exponent已经是正负两种情况下，我们继续分情况讨论： 若n为偶数，$a^n = a^n/2 * a^n/2$ 若n为奇数，$a^n=(a^{(n-1)} /2) (a^{(n-1)}/2)) a$ 时间复杂度为$O(logn)$，空间复杂度为$O(1)$。 public double myPow(double base, int exponent) { // 递归终止的条件 boolean flag = exponent > 1); // 本级递归应该做什么 if ((exponent & 1) == 1) return flag ? 1/(half*half*base) : half*half*base; else return flag ? 1/(half*half) : half*half; } "},"面试题17_打印从1到最大的n位数.html":{"url":"面试题17_打印从1到最大的n位数.html","title":"面试题17：打印从1到最大的n位数","keywords":"","body":"题目描述 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 示例 1: 输入: n = 1 输出: [1,2,3,4,5,6,7,8,9] 题解一 最大的n位数是$10^n-1$，最简单的想法是按顺序打印即可。但是当n很大时，int类型或是long类型可能都会溢出。 public int[] printNumbers(int n) { int[] res = new int[(int) Math.pow(10, n) - 1]; for (int i = 0; i 题解二 字符串能够简单有效地表示大数，考虑到题目中n的大小是不确定的，因此使用字符串来解决大数问题。如果允许我们在数字前面补0，那么n位所有十进制数其实是n个从0到9的全排列，在存入整数数组的时候将前面的0去掉即可。对于开头是0的字符串，可以Integer.valueOf()函数强转为int类型。使用DFS进行回溯，由于n位数中是可以出现重复数字的，所以不需要进行剪枝。 public int[] printNumbers(int n) { ArrayList res = new ArrayList<>(); backTrack(res, n, new StringBuilder()); int[] resArr = new int[(int) Math.pow(10, n) - 1]; for (int i = 0; i res, int n, StringBuilder builder) { if (builder.length() == n) { res.add(Integer.valueOf(builder.toString())); return; } for (int i = 0; i "},"面试题18_I_删除链表的节点.html":{"url":"面试题18_I_删除链表的节点.html","title":"面试题18-I：删除链表的节点","keywords":"","body":"题目描述 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 注意：此题对比原题有改动 示例 1: 输入: head = [4,5,1,9], val = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9. 示例 2: 输入: head = [4,5,1,9], val = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9. 题解 为方便操作，设置哑节点。并使用前驱指针pre和工作指针p一起进行遍历，若遍历到值为val的节点，则删除。 时间复杂度为$O(n)$，空间复杂度为$O(1)$。 public ListNode deleteNode(ListNode head, int val) { ListNode dummy = new ListNode(-1); dummy.next = head; ListNode pre = dummy; ListNode p = pre.next; while (p != null) { if (p.val == val) { pre.next = p.next; break; } else { p = p.next; pre = pre.next; } } return dummy.next; } "},"面试题18_II_删除链表中重复的节点.html":{"url":"面试题18_II_删除链表中重复的节点.html","title":"面试题18-II：删除链表中重复的节点","keywords":"","body":"题目描述 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1->2->3->3->4->4->5 处理后为 1->2->5 题解 为方便操作，设置哑节点。使用pre指针指向不重复的节点，head作为工作指针往后搜索。这里有一个细节，当找到重复节点的时候，还要继续向下遍历，确定后面是否还有重复的节点，若有，继续删除。 时间复杂度为$O(n)$，空间复杂度为$O(1)$。 public ListNode deleteDuplication(ListNode head) { ListNode dummy = new ListNode(0); dummy.next = head; ListNode pre = dummy; while (head != null && head.next != null) { if (head.val == head.next.val) { while (head.next != null && head.val == head.next.val) head = head.next; pre.next = head.next; head = pre.next; } else { pre = pre.next; head = head.next; } } return dummy.next; } "},"面试题19_正则表达式匹配.html":{"url":"面试题19_正则表达式匹配.html","title":"面试题19：正则表达式匹配","keywords":"","body":"题目描述 请实现一个函数用来匹配包含 '. ' 和 '' 的正则表达式。模式中的字符 '.' 表示任意一个字符，而 '' 表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串\"aaa\"与模式\"a.a\"和\"abaca\"匹配，但与\"aa.a\"和\"ab*a\"均不匹配。 示例 1: 输入: s = \"aa\" p = \"a\" 输出: false 解释: \"a\" 无法匹配 \"aa\" 整个字符串。 示例 2: 输入: s = \"aa\" p = \"a*\" 输出: true 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。 示例 3: 输入: s = \"ab\" p = \".*\" 输出: true 解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。 示例 4: 输入: s = \"aab\" p = \"c*a*b\" 输出: true 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。 示例 5: 输入: s = \"mississippi\" p = \"mis*is*p*.\" 输出: false s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 题解 定义状态 使用动态规划的方法，首先是定义状态，dp[i][j]代表 s 的前 i 个字符串s[0, i)与 p 的前 j 个字符串是否匹配。 边界条件 两个空字符串一定匹配，从代码角度来看，对于 s：a， p：a，dp[1][1] = dp[0][0]，故dp[0][0] = true p 为空时，两个字符串一定不匹配，故dp[i][0] = false s 为空且 p 中对应元素为星号时，p 中的星号可以让星号前面一个元素消失，故dp[0][j]=dp[0][j-2] 接下来分情况讨论。 一、s 对应元素与 p 对应元素相等，s[i-1] == p[j-1] 此时dp[i][j] = dp[i-1][j-1] 二、s 对应元素与 p 对应元素不相等，s[i-1] != p[j-1] 这里又分为三种情况： p[j-1] = '.'，点代表任意一个字符，相当于s[i-1] == p[j-1]，此时dp[i][j] = dp[i-1][j-1] p[j-1] = '*'，星号代表前面的那个字符可以出现任意次，这里又分为三种情况，分别是星号代表前面0个字符、1个字符以及n个字符的情况。 例如，s：aab，p：aabb*，星号匹配 0 个前面的那个字符，可将星号和星号前面的字符删除，则dp[i][j] = dp[i][j-2]; 例如，s：aab，p：aab*，星号匹配 1 个前面的那个字符，此时dp[i][j-1]已经匹配，即如果s[i-1] == p[j-2] || p[j-2] == '.'，可将星号删除，则dp[i][j] = dp[i][j-1] 例如，s：aabbbbbbbb，p：aab*，星号匹配 n 个前面的那个字符，即dp[i][j] = dp[i-1][j] s[i-1] != p[j-1]，字符串本身不相等，直接判定不匹配，dp[i][j] = false; 参考代码 public boolean isMatch(String s, String p) { int sLength = s.length(), pLength = p.length(); if (sLength == 0 && pLength == 0) return true; boolean[][] dp = new boolean[sLength+1][pLength+1]; // 边界条件： // 初始化dp数组，两个空字符串一定匹配，故dp[0][0]=true // p为空时，两个字符串一定不匹配，故dp[i][0] = false // s为空且p中对应元素为星号时，p中的星号可以让星号前面一个元素消失，故dp[0][j]=dp[0][j-2] dp[0][0] = true; for (int j = 1; j "},"面试题20_表示数值的字符串.html":{"url":"面试题20_表示数值的字符串.html","title":"面试题20：表示数值的字符串","keywords":"","body":"题目描述 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串\"+100\"、\"5e2\"、\"-123\"、\"3.1416\"、\"0123\"及\"-1E-16\"都表示数值，但\"12e\"、\"1a3.14\"、\"1.2.3\"、\"+-5\"及\"12e+5.4\"都不是。 题解 将字符串分为三个部分，A是一开始数值的整数部分，B是小数点后的小数部分，C是指数e或E后面的数值部分。由题意，A和B至少要存在一个，当e和E出现时，C就一定要存在。且A和C部分都可以有正负号，但B部分不能有。设置全局变量index，用于表示扫描字符串时的索引。按顺序一次扫描字符串，一开始扫描A，遇到小数点后扫描B，遇到e或E后扫描C。 有两处细节： 使用辅助函数scanInteger扫描数值，当signed为true时扫描正负号，sign为false时不扫描正负号。 如果存在指数e或E，但是没有C，就直接返回false。 int index = 0; public boolean isNumber(String s) { s = s.trim(); if (s.length() == 0) return false; boolean A = scanInteger(s, true), B = false, C; if (index = '0' && s.charAt(index) start; } "},"面试题21_调整数组顺序使奇数位于偶数前面.html":{"url":"面试题21_调整数组顺序使奇数位于偶数前面.html","title":"面试题21：调整数组顺序使奇数位于偶数前面","keywords":"","body":"题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 示例： 输入：nums = [1,2,3,4] 输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 题解一 第一种方法是使用冒泡排序的思想，从前往后两两比较相邻元素的值，若为逆序则交换，直到序列比较完。这样的过程是一趟冒泡，结果是将奇数调整到偶数前面（就像气泡一样浮出水面）。下一趟冒泡时，序列的第一位都是奇数，待排序列就减少一个元素，每趟冒泡都将序列中的一个奇数放到了序列的最终位置。这样的话，最多n-1趟就可以将所有元素排好序。 时间复杂度为$O(n^2)$，空间复杂度为$O(1)$。 public int[] exchange(int[] nums) { for (int i = 0; i i; j--) { if ((nums[j] & 1) == 1 && (nums[j-1] & 1) == 0) { int temp = nums[j]; nums[j] = nums[j-1]; nums[j-1] = temp; } } } return nums; } 题解二 第二种方法是新建一个数组，以空间换时间。遍历所有数组元素，先将奇数添加到新数组中，再将偶数添加到新数组中。 时间复杂度为$O(n)$，空间复杂度为$O(n)$。 public int[] exchange(int[] nums) { int[] res = new int[nums.length]; int index = 0; for (int num : nums) if ((num & 1) == 1) res[index++] = num; for (int num : nums) if ((num & 1) == 0) res[index++] = num; return res; } "},"面试题22_链表的倒数第k个节点.html":{"url":"面试题22_链表的倒数第k个节点.html","title":"面试题22：链表的倒数第k个节点","keywords":"","body":"题目描述 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。 示例： 给定一个链表: 1->2->3->4->5, 和 k = 2. 返回链表 4->5. 题解 使用快慢指针，令快指针先走k个节点，然后快慢指针同时开始遍历，当快指针到达链表尾部时，慢指针刚好指向的是链表的倒数第k个节点。 时间复杂度为$O(n)$，空间复杂度为$O(1)$。 public ListNode getKthFromEnd(ListNode head, int k) { if (head == null) return null; ListNode p = head; for (int i = 0; i "},"面试题23_链表中环的入口节点.html":{"url":"面试题23_链表中环的入口节点.html","title":"面试题23：链表中环的入口节点","keywords":"","body":"题目描述 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 题解 基本思路 首先要确定这个链表中包含环。 然后找到环的长度，根据环的长度找到环的入口节点。 先上结论，然后再证明： 结论1：设置快慢指针，快指针每次走一步，慢指针每次走两步，假如链表中有环，它们一定在环中相遇。 结论2：假设环的长度是n，先让快指针走n步，然后快慢指针一起出发，每次一起走一步，最后一定相遇于环的入口节点。 证明 证明1：快指针先进入环，慢指针后进入环，快指针走的比慢指针快，一定可以追上慢指针，只是时间问题。 证明2：假设环的长度是n，环的入口节点到链表头结点之间的长度是k。快指针先向前移动n步，则此刻节点的位置距离环的入口节点的距离为n-k，那么此刻节点的位置绕环一圈到环的入口节点的距离为n-(n-k)=k，与环的入口节点到链表头结点的距离相同，即证明快慢指针最后一定相遇于环的入口节点。 public ListNode EntryNodeOfLoop(ListNode head) { // 当头结点为空或只有一个头结点时，一定没有环 if (head == null || head.next == null) return null; ListNode low = head, fast = head; int cycleLength = 1; while (low != null && fast != null) { low = low.next; fast = fast.next.next; // 根据结论1，当low和fast相遇时，链表中一定有环，然后计算环的长度 if (low == fast) { fast = fast.next; while (low != fast) { fast = fast.next; cycleLength++; } break; } } // 如果链表没有环，则low或fast指针到达链表末尾，为空 if (low == null || fast == null) return null; // 重置low和fast指针，根据结论2寻找环的入口节点 low = head; fast = head; while (cycleLength-- > 0) fast = fast.next; while (low != fast) { low = low.next; fast = fast.next; } return low; } "},"面试题24_反转链表.html":{"url":"面试题24_反转链表.html","title":"面试题24：反转链表","keywords":"","body":"题目描述 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例： 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL 题解 使用头插法原地逆置链表。为了便于操作，首先定义一个哑节点。然后从第一个节点开始，依次头插到头节点的后面，直到最后一个节点，从而实现链表的原地逆置。 具体来说，当前节点不为空时，用r指针保存下一个节点，然后将当前节点的next指针指向dummy的下一个节点，然后dummy的next指针指向当前节点，再将当前指针指向r指针保存的节点。 时间复杂度为$O(n)$，空间复杂度为$O(1)$。 public ListNode reverseList(ListNode head) { ListNode dummy = new ListNode(0); while (head != null) { ListNode r = head.next; head.next = dummy.next; dummy.next = head; head = r; } return dummy.next; } "},"面试题25_合并两个排序的链表.html":{"url":"面试题25_合并两个排序的链表.html","title":"面试题25：合并两个排序的链表","keywords":"","body":"题目描述 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 示例： 输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4 题解一 为了便于操作，定义一个哑节点。当两个链表中都有元素时，遍历两个链表，依次将较小的元素添加到哑节点后。当一个链表中的元素全部添加完毕后，将另一个链表中的元素全部添加到哑节点后。 时间复杂度为$O(n)$，空间复杂度为$O(1)$。 public ListNode mergeTwoLists(ListNode list1, ListNode list2) { ListNode dummy = new ListNode(0); ListNode p = dummy; while (list1 != null && list2 != null) { if (list1.val 题解二 递归终止的条件是其中一个链表为空，则直接返回另一个链表。在本级递归中，将从下一级递归函数中获得的返回值链接到当前较小节点的尾部，然后返回这个较小的节点。 时间复杂度为$O(n)$，空间复杂度为$O(1)$。 public ListNode Merge(ListNode list1, ListNode list2) { if (list1 == null) return list2; if (list2 == null) return list1; if (list1.val "},"面试题26_树的子结构.html":{"url":"面试题26_树的子结构.html","title":"面试题26：树的子结构","keywords":"","body":"题目描述 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) B是A的子结构， 即 A中有出现和B相同的结构和节点值。 例如: 给定的树 A: 3 / \\ 4 5 / \\ 1 2 给定的树 B： 4 / 1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。 题解 判断一个树B是不是另一个树A的子结构，首先需要在树A中找到和树B的根节点一样的节点，然后再判断以这个节点为根节点的子树是不是和树B相同。 对于在树A中寻找与树B的根节点的值相同的节点，可以用先序遍历的方法或是层次遍历的方法实现，这里用先序遍历的方法实现。如果找到了这个节点，那么需要判断以这个节点为根节点的子树是否和树B相同，同样可以用先序遍历的方法实现。 public boolean isSubStructure(TreeNode root1, TreeNode root2) { boolean flag = false; if (root1 == null || root2 == null) return false; if (root1.val == root2.val) flag = DoesTree1HaveTree2(root1, root2); if (!flag) flag = isSubStructure(root1.left, root2); if (!flag) flag = isSubStructure(root1.right, root2); return flag; } private boolean DoesTree1HaveTree2(TreeNode node1, TreeNode node2) { // 如果node2遍历完了，说明之前的都能对应，返回true if (node2 == null) return true; // 如果node2没有遍历完，但node1却遍历完了，返回false；或者当前根节点没有对应上，也返回false if (node1 == null || node1.val != node2.val) return false; // 进入node1的子节点中进行递归 return DoesTree1HaveTree2(node1.left, node2.left) && DoesTree1HaveTree2(node1.right, node2.right); } "},"面试题27_二叉树的镜像.html":{"url":"面试题27_二叉树的镜像.html","title":"面试题27：二叉树的镜像","keywords":"","body":"题目描述 请完成一个函数，输入一个二叉树，该函数输出它的镜像。 例如输入： 4 / \\ 2 7 / \\ / \\ 1 3 6 9 镜像输出： 4 / \\ 7 2 / \\ / \\ 9 6 3 1 题解 这题是典型的先序遍历，先序遍历这棵树的每个节点，如果遍历到节点有子节点，那么就递归交换它的子节点。 时间复杂度为$O(n)$，空间复杂度为$O(logn)$。 public TreeNode mirrorTree(TreeNode root) { mirrorTreeHelper(root); return root; } private void mirrorTreeHelper(TreeNode root) { if (root == null) return; if (root.left == null && root.right == null) return; TreeNode temp = root.left; root.left = root.right; root.right = temp; if (root.left != null) mirrorTreeHelper(root.left); if (root.right != null) mirrorTreeHelper(root.right); } "},"面试题28_对称的二叉树.html":{"url":"面试题28_对称的二叉树.html","title":"面试题28：对称的二叉树","keywords":"","body":"题目描述 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 题解 这道题使用递归比较简单，由题意可知，如果一棵树是对称的二叉树，那么它镜像对称。如果能够满足下面两个条件，那么两棵树互为镜像： 两棵树的根节点相等。 每棵树的左子树都与另一棵树的右子树对称。 那么判断一棵树是否为对称的二叉树，只需要创建一棵一模一样的树，判断这两棵树是否互为镜像即可。 public boolean isSymmetric(TreeNode root) { return isSymmetricHelper(root, root); } private boolean isSymmetricHelper(TreeNode root1, TreeNode root2) { if (root1 == null && root2 == null) return true; if (root1 == null || root2 == null || root1.val != root2.val) return false; return isSymmetricHelper(root1.left, root2.right) && isSymmetricHelper(root1.right, root2.left); } "},"面试题29_顺时针打印矩阵.html":{"url":"面试题29_顺时针打印矩阵.html","title":"面试题29：顺时针打印矩阵","keywords":"","body":"题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2： 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] 题解 从外向内逐层打印矩阵，当外圈打印完成时，内圈仍然是个矩阵。 首先初始化上下左右的边界，先向右打印，第一行打印完，重新设定上边界； 然后向下打印，最后第一列打印完，重新设定右边界； 然后向左打印，最后一行打印完，重新设定下边界； 最后向上打印，第一列打印完，重新设定左边界。 然后不断循环以上过程即可。 public int[] spiralOrder(int[][] matrix) { if (matrix.length == 0) return new int[] {}; int m = matrix.length, n = matrix[0].length, index = 0; int[] res = new int[m * n]; int upper = 0, down = m-1, left = 0, right = n-1; while (true) { // 向右 for (int i = left; i = left; i--) res[index++] = matrix[down][i]; if (down-- == upper) break; // 向上 for (int i = down; i >= upper; i--) res[index++] = matrix[i][left]; if (left++ == right) break; } return res; } "},"面试题30_包含min函数的栈.html":{"url":"面试题30_包含min函数的栈.html","title":"面试题30：包含min函数的栈","keywords":"","body":"题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 示例: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.min(); --> 返回 -3. minStack.pop(); minStack.top(); --> 返回 0. minStack.min(); --> 返回 -2. 题解 创建MinStack作为所求的数据结构。首先初始化两个栈，一个栈和普通栈一样，用于正常的push和pop，另一个作为辅助栈用于存放最小值。 push()：普通栈正常push，如果辅助栈为空，那么当前push的值肯定是最小值，直接存入辅助栈。如果push的值比当前辅助栈栈顶元素小，也可以存入辅助栈。 pop()：普通栈正常pop，如果普通栈pop的元素与辅助栈栈顶元素相同，那么辅助栈也pop。 top()：返回普通栈栈顶元素（不用删除）。 min()：辅助栈栈顶就是普通栈中的最小值，直接输出栈顶元素。 class MinStack { public Stack stack; public Stack assist_stack; MinStack() { stack = new Stack<>(); assist_stack = new Stack<>(); } public void push(int node) { stack.push(node); if (assist_stack.empty() || node "},"面试题31_栈的压入弹出序列.html":{"url":"面试题31_栈的压入弹出序列.html","title":"面试题31：栈的压入弹出序列","keywords":"","body":"题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 示例 1： 输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1] 输出：true 解释：我们可以按以下顺序执行： push(1), push(2), push(3), push(4), pop() -> 4, push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1 示例 2： 输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2] 输出：false 解释：1 不能在 2 之前弹出。 题解 借用辅助栈，遍历一遍压栈序列，将pushA中的元素放入栈中，判断栈顶元素是否和出栈序列中对应的元素相等，若不相等继续压栈，相等则出栈。 循环完毕后，即压栈序列中的所有元素全部压栈完毕。如果辅助栈为空，说明全部出栈完毕，返回true，否则返回false。 下面给出两种实现方法： public boolean validateStackSequences(int[] pushA,int[] popA) { if (pushA.length != popA.length) return false; int index1 = 0, index2 = 0; Stack stack = new Stack<>(); // 当栈不为空或pushA中元素没有全部压栈时循环 while (!stack.empty() || index1 public boolean validateStackSequences(int[] pushA,int[] popA) { if (pushA.length != popA.length) return false; int indexPop = 0; Stack stack = new Stack<>(); // 遍历压栈序列 for (int num : pushA) { stack.push(num); // 每次压栈之后都试试是否能够出栈 while (!stack.empty() && stack.peek() == popA[indexPop]) { stack.pop(); indexPop++; } } return stack.empty(); } "},"面试题32_1_从上到下打印二叉树.html":{"url":"面试题32_1_从上到下打印二叉树.html","title":"面试题32-I：从上到下打印二叉树","keywords":"","body":"题目描述 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 示例： 给定二叉树: [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回： [3,9,20,15,7] 题解 利用队列进行简单的层次遍历即可。 public int[] levelOrder(TreeNode root) { ArrayList res = new ArrayList<>(); Queue queue = new LinkedList<>(); if (root == null) return new int[] {}; queue.offer(root); while (!queue.isEmpty()) { TreeNode p = queue.poll(); res.add(p.val); if (p.left != null) queue.offer(p.left); if (p.right != null) queue.offer(p.right); } int[] resArr = new int[res.size()]; for (int i = 0; i "},"面试题32_2_把二叉树打印成多行.html":{"url":"面试题32_2_把二叉树打印成多行.html","title":"面试题32-II：把二叉树打印成多行","keywords":"","body":"题目描述 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 示例： 给定二叉树: [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [9,20], [15,7] ] 题解 大体框架与层次遍历相同，只是为了记录每层的节点数目，设置一个变量size，用于对当前层的节点进行遍历。 public List> levelOrder(TreeNode root) { List> res = new ArrayList<>(); Queue queue = new LinkedList<>(); queue.offer(root); if (root == null) return res; while (!queue.isEmpty()) { int size = queue.size(); ArrayList list = new ArrayList<>(); for (int i = 0; i "},"面试题32_3_按之字形顺序打印二叉树.html":{"url":"面试题32_3_按之字形顺序打印二叉树.html","title":"面试题32-III：按之字形顺序打印二叉树","keywords":"","body":"题目描述 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 示例： 给定二叉树: [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [20,9], [15,7] ] 题解 用两个栈实现，一个栈stackToRight用于保存需要从左往右打印的节点，另一个栈stackToLeft用于保存下一层需要从右往左打印的节点。 由题意，第一行按照从左到右的顺序打印，因此把根节点加入stackToRight中。然后循环开始，当stackToRight不为空时，则把其下一层的节点添加到stackToLeft中（注意左右子节点添加的顺序）；当stackToLeft不为空时，则把其下一层的节点添加到stackToRight中（注意左右子节点添加的顺序）。与此同时，使用list记录打印的节点。当两个栈都为空时循环结束。 public List> levelOrder(TreeNode root) { List> res = new ArrayList<>(); Stack stackToRight = new Stack<>(); Stack stackToLeft = new Stack<>(); if (root == null) return res; stackToRight.push(root); while (!stackToRight.isEmpty() || !stackToLeft.isEmpty()) { if (!stackToRight.isEmpty()) { ArrayList list = new ArrayList<>(); while (!stackToRight.isEmpty()){ TreeNode p = stackToRight.pop(); list.add(p.val); if (p.left != null) stackToLeft.push(p.left); if (p.right != null) stackToLeft.push(p.right); } res.add(list); } if (!stackToLeft.isEmpty()) { ArrayList list = new ArrayList<>(); while (!stackToLeft.isEmpty()){ TreeNode p = stackToLeft.pop(); list.add(p.val); if (p.right != null) stackToRight.push(p.right); if (p.left != null) stackToRight.push(p.left); } res.add(list); } } return res; } "},"面试题33_二叉搜索树的后序遍历序列.html":{"url":"面试题33_二叉搜索树的后序遍历序列.html","title":"面试题33：二叉搜索树的后序遍历序列","keywords":"","body":"题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。 参考以下这颗二叉搜索树： 5 / \\ 2 6 / \\ 1 3 示例 1： 输入: [1,6,3,2,5] 输出: false 示例 2： 输入: [1,3,2,6,5] 输出: true 题解 若一个树为一个二叉搜索树，则它左子树上的节点一定比根节点小，右子树上的节点一定比根节点大，且它的左右子树一定也为二叉搜索树。 解题思路： 首先找到左子树和右子树的开始坐标和结束坐标，得到左子数组和右子数组。 验证左子数组中的元素是否都小于根节点，右子数组中的元素是否都大于根节点。 若满足条件，则进行递归验证左子树和右子树是否都是二叉搜索树（利用'或'门的短路性质，子树为空不进行判断）。 给出两种实现方法： public boolean verifyPostorder(int[] sequence) { if (sequence.length == 0) return true; int len = sequence.length; int root = sequence[len-1]; int leftBegin = 0, leftEnd = 0; // 找左子树的开始坐标和结束坐标 while (leftEnd root) break; leftEnd++; } // 找右子树的开始坐标和结束坐标 int rightEnd = leftEnd, rightBegin = leftEnd; while (rightEnd root) return false; for (int num : rightArr) if (num public boolean verifyPostorder(int[] sequence) { if (sequence.length == 0) return true; return verifyPostorderHelper(sequence, 0, sequence.length-1); } public boolean verifyPostorderHelper(int[] sequence, int left, int right) { // 当子树为空或子树只有一个节点时，直接返回true if (left >= right) return true; int i = right; // 找到右子树的起点i while (i > left && sequence[i-1] > sequence[right]) i--; // 从左子树的终点开始，验证左子树是否小于根节点 for (int j = i-1; j >= left; j--) { if (sequence[j] > sequence[right]) return false; } return verifyPostorderHelper(sequence, left, i-1) && verifyPostorderHelper(sequence, i, right-1); } "},"面试题34_二叉树中和为某一值的路径.html":{"url":"面试题34_二叉树中和为某一值的路径.html","title":"面试题34：二叉树中和为某一值的路径","keywords":"","body":"题目描述 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 示例： 给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回: [ [5,4,11,2], [5,8,4,5] ] 题解 本题的路径指从树的根节点开始一直到叶节点所经过的节点形成的路径。由于只有前序遍历是先访问根节点，所以使用前序遍历+回溯。 首先定义一个大容器，用于盛放符合要求的路径。然后开始回溯。 回溯函数有两个部分： 首先判断是否满足结束条件，如果满足就将当前路径添加到容器中。 然后遍历可选择的列表（本题的选择列表是当前节点的左右子树），在遍历结束后进行回溯。 最后别忘了，由于题目要求在返回值的list中，数组长度大的数组靠前，因此还要对得到的大容器按照路径的长度进行排序。 List> res = new ArrayList<>(); public List> pathSum(TreeNode root, int target) { if (root == null) return res; BackTrack(root, target, new ArrayList<>(), 0); // 定义比较器 Collections.sort(res, new Comparator>() { @Override public int compare(List o1, List o2) { return o2.size() - o1.size(); } }); return res; } public void BackTrack(TreeNode node, int target, ArrayList path, int currentSum) { currentSum += node.val; path.add(node.val); // 如果到达叶节点且路径和等于target，则将得到一条符合要求的路径 if (node.left == null && node.right == null && currentSum == target) res.add(new ArrayList<>(path)); // 如果不是叶节点，那么继续递归遍历它的子节点 if (node.left != null) BackTrack(node.left, target, path, currentSum); if (node.right != null) BackTrack(node.right, target, path, currentSum); // 回溯 path.remove(path.size()-1); } "},"面试题35_复杂链表的复制.html":{"url":"面试题35_复杂链表的复制.html","title":"面试题35：复杂链表的复制","keywords":"","body":"题目描述 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 示例1： 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例2： 输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]] 示例3： 输入：head = [[3,null],[3,0],[3,null]] 输出：[[3,null],[3,0],[3,null]] 题解一 使用哈希表保存原链表和复制后链表的指针。 第一个遍历将原链表的next指针复制一遍，同时保存对应的指针（确保原链表中的每一个节点都能在复制后链表中找到）。 第二个遍历将原链表的random指针复制一遍（从哈希表中取对应节点）。 时间复杂度为O(n)，空间复杂度为O(n)。 /* // Definition for a Node. class Node { int val; Node next; Node random; public Node(int val) { this.val = val; this.next = null; this.random = null; } } */ public Node copyRandomList(Node head) { if (head == null) return null; Node headClone = new Node(head.val); HashMap map = new HashMap<>(); map.put(head, headClone); // 第一个遍历复制next指针 Node p = head.next; Node pClone = headClone; while (p != null) { pClone.next = new Node(p.val); pClone = pClone.next; map.put(p, pClone); p = p.next; } // 第二个遍历复制random指针 p = head; pClone = headClone; while (p != null) { if (p.random != null) pClone.random = map.get(p.random); p = p.next; pClone = pClone.next; } return headClone; } 题解二 在原链表的每个节点后都添加一个节点作为复制后的节点。 给复制后的节点添加random指针。 把第二步得到的链表拆分成两个链表。 时间复杂度为O(n)，空间复杂度为O(1)。 public Node copyRandomList(Node head) { if (head == null) return null; // 1.在原链表的每个节点后都添加一个节点作为复制后的节点。 Node p = head; Node r; while (p != null) { r = new Node(p.val); r.next = p.next; p.next = r; p = r.next; } // 2.添加random指针。 p = head; while (p != null) { if (p.random != null) p.next.random = p.random.next; p = p.next.next; } // 3.拆分两个链表。 p = head; r = head.next; Node headClone = r; while (p != null) { p.next = p.next.next; if (r != null && r.next != null) r.next = r.next.next; p = p.next; r = r.next; } return headClone; } "},"面试题36_二叉搜索树与双向链表.html":{"url":"面试题36_二叉搜索树与双向链表.html","title":"面试题36：二叉搜索树与双向链表","keywords":"","body":"题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 题解 对二叉搜索树进行中序遍历，可得到递增的顺序，所以在中序遍历时完成相邻两个节点的互指即可。 TreeNode pre = null; public TreeNode Convert(TreeNode root) { if (root == null) return null; ConvertHelper(root); // 转换结束，返回双向链表表头 while (root.left != null) root = root.left; return root; } public void ConvertHelper(TreeNode cur) { if (cur == null) return; ConvertHelper(cur.left); // 建立双向链表 cur.left = pre; if (pre != null) pre.right = cur; pre = cur; ConvertHelper(cur.right); } "},"面试题37_序列化二叉树.html":{"url":"面试题37_序列化二叉树.html","title":"面试题37：序列化二叉树","keywords":"","body":"题目描述 请实现两个函数，分别用来序列化和反序列化二叉树 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。 二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。 题解 这题的细节特别麻烦，折腾了好久才AC成功。本题对于二叉树的序列化和反序列化的规则是自定义的，即给定一个二叉树，可以以自定义的规则进行序列化，但是要保证反序列化出的二叉树和输入的二叉树一模一样。我的规则是在每个节点后输出一个逗号，例如： 1 / \\ 2 3 / \\ 4 5 输入的二叉树如上所示，经序列化后，得到字符串：\"1,2,#,#,3,4,#,#,5,#,#,\" 这里使用先序遍历的深度优先查找，序列化二叉树即在先序遍历二叉树时将节点输出。重点是在碰到空节点时也要输出#，因为序列中的#能够决定二叉树的结构，没有这个空节点#，单靠先序序列是无法恢复出原来的二叉树的，即反序列化。 在反序列化时，也是使用先序遍历的模板，用到了StringBuilder这个数据结构，而不直接用String。因为String在java中是不可变对象，是被final修饰的，每次对String修改，都会创建一个新的String，浪费时间和空间。除了StringBuilder，也可以考虑使用字符数组的方式，这就需要考虑索引的问题了。 下面是参考代码： public String serialize(TreeNode root) { StringBuilder builder = new StringBuilder(); serializeHelper(root, builder); return builder.toString(); } private void serializeHelper(TreeNode node, StringBuilder builder) { if (node == null) { builder.append(\"#,\"); return; } builder.append(node.val).append(','); serializeHelper(node.left, builder); serializeHelper(node.right, builder); } public TreeNode deserialize(String str) { return deserializeHelper(new StringBuilder(str)); } private TreeNode deserializeHelper(StringBuilder builder) { // 递归终止条件与空节点的处理 if (builder.length() == 0) return null; if (builder.charAt(0) == '#') { builder.delete(0,2); return null; } // 取出当前根节点的值存进num int index = builder.indexOf(\",\"); int num = Integer.parseInt(builder.substring(0,index)); builder.delete(0,index+1); // 先序遍历 TreeNode root = new TreeNode(num); root.left = deserializeHelper(builder); root.right = deserializeHelper(builder); return root; } "},"面试题38_字符串的排列.html":{"url":"面试题38_字符串的排列.html","title":"面试题38：字符串的排列","keywords":"","body":"题目描述 输入一个字符串，打印出该字符串中字符的所有排列。 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 示例： 输入：s = \"abc\" 输出：[\"abc\",\"acb\",\"bac\",\"bca\",\"cab\",\"cba\"] 题解 本题实际上是全排列问题，是回溯法的典型应用，在回溯法的基础加上了状态重置和剪枝。 回溯可以理解为“恢复现场”，是为了节约时间和空间的一种技巧。回溯本质上是深度优先遍历，因为用到回溯的问题通常都是在一棵树上完成的，我们使用深度优先遍历在这棵树上寻找最终的答案。 设置一个状态数组，初始化的时候状态数组中的元素都为false，表示所有元素都没有被选择。当选择一个元素时，就设置状态为true，表示当前元素被选择，在考虑下一个位置的时候就可以判断还剩余哪些元素可供选择。 注意：在判断是否满足结束条件的时候，不可以直接 res.add(路径)，否则最终得到的结果会全为空。这是因为DFS完成遍历之后会撤销之前所有的选择，路径在回到根节点之后为空。 而在Java中都是值传递，在传参的过程中复制的是变量的地址。如果每次在满足结束条件的时候只是简单地 res.add(路径)，这实际上所有的路径指向的都是同一块内存地址，因此在将路径添加到容器中时需要做一次深拷贝，即 res.add(new 路径)。 给出一个回溯法的框架： res = [] def Permutation(String): BackTracking() return res def BackTracking(选择列表, 路径, 状态): if 满足结束条件: res.add(new 路径) return for 选择 in 选择列表: 剪枝 做选择 BackTracking(选择列表, 路径, 状态) 撤销选择 参考代码： public ArrayList res = new ArrayList<>(); public ArrayList Permutation(String str) { if (str.length() == 0 || str.length() >= 9) return res; BackTracking(str, new StringBuilder(), new boolean[str.length()]); return res; } // 设置flag标志进行剪枝 public void BackTracking(String str, StringBuilder sb, boolean[] flags) { if (sb.length() == str.length() && !res.contains(sb.toString())) { res.add(sb.toString()); return; } for (int i = 0; i "},"面试题39_数组中出现次数超过一半的数字.html":{"url":"面试题39_数组中出现次数超过一半的数字.html","title":"面试题39：数组中出现次数超过一半的数字","keywords":"","body":"题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 示例 : 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2] 输出: 2 题解一 对于排序的数组，数组中出现次数超过一半的数字一定会出现在数组的中间。于是先将数组排序，然后输出中位数即可。但是由于输入的数组不一定满足要求，所以别忘了检查得到的数字是否真的在数组中出现的次数超过一半。 时间复杂度为O(nlogn)，空间复杂度为O(1)。 public int MoreThanHalfNum_Solution(int[] array) { Arrays.sort(array); int res = array[array.length >> 1]; return Check(array, res) ? res : 0; } private boolean Check(int[] array, int number) { int times = 0; for (int num : array) if (num == number) times++; return times > array.length >> 1; } 题解二 一个直观的解法是使用哈希表。遍历一遍数组，将数组中每个元素出现的次数存入哈希表，然后遍历哈希表，找出出现次数大于一半的数字。 时间复杂度为O(n)，空间复杂度为O(n)。 public int MoreThanHalfNum_Solution(int[] array) { HashMap map = new HashMap<>(); for (int num : array) { if (!map.containsKey(num)) map.put(num, 1); else map.put(num, map.get(num)+1); } for (HashMap.Entry entry : map.entrySet()) { if (entry.getValue() > array.length/2) return entry.getKey(); } return 0; } 题解三 考虑数组的特性，若数组中有一个数字出现的次数超过了数组长度的一半，那么数组中第n/2大的数字一定是这个数字。 借助快排的思想，每次Partition都可以将pivot放置到其对应的位置，且所有小于pivot的数字都在pivot左边，大于pivot的数字都在pivot右边。排序后数组中的下标为数组长度一半的数字即为数组中第n/2大的数字（数组的中位数）。 为了找到这个数字，我们可以使用递归，如果pivot的坐标小于n/2，那么继续在pivot右边进行查找；如果pivot的坐标大于n/2，那么继续在pivot左边进行查找；如果pivot的坐标刚好等于n/2，那么就返回数组中对应的数字。 最后别忘了检查得到的数字是否真的在数组中出现的次数超过一半，毕竟上述算法得到的只是这个数组中第n/2大的数字，并不保证这个数字出现次数超过一半。 时间复杂度为O(n)，空间复杂度为O(1)。 public int MoreThanHalfNum_Solution(int[] array) { int length = array.length; int middle = length >> 1; int pivotPos = Partition(array, 0, length-1); while (pivotPos != middle) { if (pivotPos > middle) pivotPos = Partition(array, 0, pivotPos-1); else pivotPos = Partition(array, pivotPos+1, length-1); } return Check(array, array[pivotPos]) ? array[pivotPos] : 0; } private int Partition(int[] array, int left, int right) { int pivot = array[left]; while (left = pivot) right--; array[left] = array[right]; while (left array.length >> 1; } 题解四 还有另外一种巧妙的方法。遍历数组，同时维护两个变量：一个是数组中的一个数字，另一个是次数。在遍历数组时，第一个数字作为守方， 设置count=1，接下来的数字进行攻击。在遇到相同元素时守方即count加1，遇到不同元素时count-1。在count为0时，新的数字成为新的守方，接受接下来的攻击。 若数组中有一个出现次数超过一半的数字，那么它一定是最终的胜利者。但也有可能不存在这与的数字，所以在结束之后也要像之前一样进行检查。 时间复杂度为O(n)，空间复杂度为O(1)。 public int MoreThanHalfNum_Solution(int[] array) { int victor = 0, count = 0; for (int num : array) { if (victor != num) { if (count == 0) { victor = num; count++; } else count--; } else count++; } return Check(array, victor) ? victor : 0; } private boolean Check(int[] array, int number) { int times = 0; for (int num : array) if (num == number) times++; return times > array.length >> 1; } "},"面试题40_最小的k个数.html":{"url":"面试题40_最小的k个数.html","title":"面试题40：最小的k个数","keywords":"","body":"题目描述 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例 1： 输入：arr = [3,2,1], k = 2 输出：[1,2] 或者 [2,1] 示例 2： 输入：arr = [0,1,2,1], k = 1 输出：[0] 题解一 最直观的解法就是对数组进行排序，然后输出前k个数。 时间复杂度为O(nlogn)，空间复杂度为O(1)。 public ArrayList GetLeastNumbers_Solution(int[] input, int k) { ArrayList res = new ArrayList<>(); if (k > input.length) return res; Arrays.sort(input); for (int i = 0; i 题解二 和上一题类似，也可以利用快排的思想。当pivot的数组下标为k时，pivot左边的k个数字都小于pivot，pivot右边的n-k个数字都大于或等于pivot。若找到这与的pivot，直接输出数组的前k个元素即可。 时间复杂度为O(n)，空间复杂度为O(1)。 public ArrayList GetLeastNumbers_Solution2(int[] input, int k) { ArrayList res = new ArrayList<>(); if (k > input.length || input.length == 0) return res; int pivotPos = Partition(input, 0, input.length-1); while (k k) pivotPos = Partition(input, 0, pivotPos-1); else pivotPos = Partition(input, pivotPos+1, input.length-1); } for (int i = 0; i = pivot) right--; array[left] = array[right]; while (left 题解三 利用最大堆的思想，维护一个大小为k的最大堆，用于存储这最小的k个数。 遍历input，与最大堆中的最大值进行比较。当输入的数字比这k个数中的最大值还小时，则用输入的数字替换这k个数中的最大值。 尽管这种算法的时间复杂度为O(nlogn)，比题解二慢一些，但它有两个优点： 没有修改输入数组的顺序。（所有操作都是在最大堆中完成的） 适合海量输入数据。（尤其是当输入数组很大而k很小时，这时候只需要维护一个大小为k的最大堆即可） 时间复杂度为O(nlogn)，空间复杂度为O(1)。 public ArrayList GetLeastNumbers_Solution3(int[] input, int k) { ArrayList res = new ArrayList<>(); if (k input.length) return res; // 构建最大堆 PriorityQueue maxHeap = new PriorityQueue<>(k, new Comparator() { @Override public int compare(Integer o1, Integer o2) { return o2.compareTo(o1); } }); // 遍历input, 并与最大堆中的最大值进行比较 for (int num : input) { if (maxHeap.size() num) { maxHeap.poll(); maxHeap.offer(num); } } res.addAll(maxHeap); return res; } "},"面试题41_数据流中的中位数.html":{"url":"面试题41_数据流中的中位数.html","title":"面试题41：数据流中的中位数","keywords":"","body":"题目描述 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 例如， [2,3,4] 的中位数是 3 [2,3] 的中位数是 (2 + 3) / 2 = 2.5 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例 1： 输入： [\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"] [[],[1],[2],[],[3],[]] 输出：[null,null,null,1.50000,null,2.00000] 示例 2： 输入： [\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"] [[],[2],[],[3],[]] 输出：[null,null,2.00000,null,2.50000] 题解 将所有数据分为两半，分别放入一个最大堆和一个最小堆中。最大堆用来存较小的数，最小堆用来存较大的数。这时候中位数就是最大堆的根节点和最小根的根节点的平均数。 这种方法一个最关键的点是：在每次插入数据时，不能直接插入，而是需要取另一个堆的根节点进行插入。这样，每次插入最小堆的是当前最大堆中最大的元素，每次插入最大堆的是当前最小堆中最小的元素，这样才能保证最大堆中的值全部小于最小堆中的值。 PriorityQueue minHeap; PriorityQueue maxHeap; Solution() { minHeap = new PriorityQueue<>(); maxHeap = new PriorityQueue<>(new Comparator() { @Override public int compare(Integer o1, Integer o2) { return o2.compareTo(o1); } }); } public void Insert(Integer num) { if (minHeap.size() == maxHeap.size()) { minHeap.offer(num); if (!minHeap.isEmpty()) maxHeap.offer(minHeap.poll()); } else { maxHeap.offer(num); if (!maxHeap.isEmpty()) minHeap.offer(maxHeap.poll()); } } public Double GetMedian() { if (minHeap.isEmpty() && maxHeap.isEmpty()) return 0.0; if (!minHeap.isEmpty() && !maxHeap.isEmpty() && minHeap.size() == maxHeap.size()) return (double) (minHeap.peek() + maxHeap.peek()) / 2; else if (!maxHeap.isEmpty()) return (double) maxHeap.peek(); else return 0.0; } "},"面试题42_连续子数组的最大和.html":{"url":"面试题42_连续子数组的最大和.html","title":"面试题42：连续子数组的最大和","keywords":"","body":"题目描述 输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 要求时间复杂度为O(n)。 示例1： 输入: nums = [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 题解 使用动态规划的思想，用dp[i]表示以第i个数字结尾的子数组的最大和。 状态转移方程： $$ dp[i] = max(dp[i-1]+array[i], array[i]) $$ 时间复杂度为$O(n)$，空间复杂度为$O(n)$。（空间复杂度可以优化，即用变量代替数组） public int FindGreatestSumOfSubArray(int[] array) { int[] dp = new int[array.length]; dp[0] = array[0]; int res = array[0]; // dp[i] = max(dp[i-1]+array[i], array[i]) for (int i = 1; i res) res = dp[i]; } return res; } "},"面试题43_1到n整数中1出现的次数.html":{"url":"面试题43_1到n整数中1出现的次数.html","title":"面试题43：1到n整数中1出现的次数","keywords":"","body":"题目描述 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。 例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。 示例 1： 输入：n = 12 输出：5 示例 2： 输入：n = 13 输出：6 题解一 最直接的解法是遍历一遍1到n，对每个数都不断对10取余得到个位的结果，看是否等于1，累加这些结果即可。 如果一个数为n，那么它有n位，故时间复杂度为O(nlogn)，空间复杂度为O(1)。 public int NumberOf1Between1AndN_Solution(int n) { int count = 0; for (int i = 1; i 0) { if (temp % 10 == 1) count++; temp /= 10; } } return count; } 题解二 除了上面这种暴力解法，我们还可以从数学规律入手。 下面这张图来自LeetCode官方题解，整理的非常好，从数字的每一位入手。 首先从个位开始考虑，对于1-10，有一个数字个位上有1；对于10-20，也是只有一个数字个位上有1；同理，对于之后出现的数字也是一样。因此，对于1-160，就有16个数字个位上有1；如果一个整数16x大于等于161且小于170，那么共有17个数字的个位上会出现1。据此可以得到公式： $$ (n / 10)*1 + min(max(n \\% 10 - 1 + 1, 0), 1) $$ 然后考虑十位，对于1-100，只有10-19可能在十位出现1；对于100-200，只有110-119可能在十位出现1；对于200-300，只有210-219可能在十位出现1；同理，对于之后出现的数字也是一样。因此，对于1-1600，就有160个数字十位上有1；如果一个整数161x大于1610且小于1619，那么共有(161+x)个数字的十位上会出现1。据此可以得到公式： $$ (n / 100) * 10 + min(max(n \\% 100 - 10 + 1, 0), 10) $$ 然后考虑百位，对于1-1000，只有100-199,可能在百位出现1；对于1000-2000，只有1100-1199可能在百位出现1；对于2000-3000，只有2100-2199可能在百位出现1；同理，对于之后出现的数字也是一样。因此，对于1-16000，就有1600个数字在百位上有1。如果一个整数161xy大于16100且小于16199，那么共有(1600+xy+1)个数字的百位上会出现1。据此可以得到公式： $$ (n/1000) * 100 + min(max(n \\% 1000 - 100 +1, 0), 100) $$ 归纳后可写出如下的代码： public int NumberOf1Between1AndN_Solution(int n) { int count = 0; for (int i = 1; i "},"面试题44_数字序列中某一位的数字.html":{"url":"面试题44_数字序列中某一位的数字.html","title":"面试题44：数字序列中某一位的数字","keywords":"","body":"题目描述 数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。 请写一个函数，求任意第n位对应的数字。 题解 这道题有特别多的边界条件，要特别小心，调了好久才调出来。对于第n位的数字，我们首先找到这位数字对应的数是几位数，然后确定这个数的数值，最后确定返回值是这个数值中的哪一个数字。 举个例子，如果要找到序列中1001位的数字。通过观察我们可以发现一些规律，序列的前10位是只有一位的数字，即0-9。接下来的180位是90个两位数，即10-99。再接下来的2700位是900个三位数，即100-999。再接下来的36000位是9000个四位数，即1000-9999......以此类推。根据这个规律可以确定1001是三位数，此时n就是以100位起点开始的位数。然后确定这个数的数值，最后确定数值value中的那个数字。 public int findNthDigit(int n) { // 找到序列中第n位的数字是几位数，存入digits中 long base = 9; byte digits = 1; while (n - base * digits > 0) { n -= base * digits; base *= 10; digits++; } // 此时n是以digits位数为起点开始的位数，然后确定这个数的数值 int value = 1; for (int i = 1; i "},"面试题45_把数组排成最小的数.html":{"url":"面试题45_把数组排成最小的数.html","title":"面试题45：把数组排成最小的数","keywords":"","body":"题目描述 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 题解 依据贪心的思想，两两比较数字之间的组合，将结果小的放置在前面。为了方便操作，首先将数字转换为字符串。 但什么样的字符串最小？题目要求的是我们找到一个排序规则，根据这个排序规则，排成一个最小的数字。为此，对于str1和str2，将它们拼接起来，有两种拼接方法，分别是str1+str2和str2+str1。直接比较这两种拼接结果，定义为一个新的排序规则。 public String minNumber(int[] nums) { String[] strNums = new String[nums.length]; for (int i = 0; i () { @Override public int compare(String o1, String o2) { return (o1+o2).compareTo(o2+o1); } }); // 拼接排序后的字符串数组 StringBuilder builder = new StringBuilder(); for (String str : strNums) builder.append(str); return builder.toString(); } "},"面试题46_把数字翻译成字符串.html":{"url":"面试题46_把数字翻译成字符串.html","title":"面试题46：把数字翻译成字符串","keywords":"","body":"题目描述 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 题解 使用动态规划的方法，对于当前的数字，我们可以只翻译这个数字，或者和前面一个数字一起翻译。 为了方便操作，将num的每一位数字存到字符数组chars中。假设当前数字是s[i]： 若当前数字与前一个数字的组合不在10-25之间，则翻译方法的总数就是s[0]到s[i-1]这个字符串翻译方法的数量。 若当前数字与前一个数字的组合在10-25之间时，在当前数字加入字符串之后，翻译方法的总数就是s[0]到s[i-1]字符串翻译方法的数量加上s[0]到s[i-2]字符串翻译方法的数量。 状态转移方程为： $$ \\begin{align} dp[i] = \\left{ \\begin{aligned} \\ & dp[i-1], 若当前数字与前一个数字的组合不在10-25之间 \\ & dp[i-1] + dp[i-2], 若当前数字与前一个数字的组合在10-25之间 \\end{aligned} \\right.\\end{align} $$ 边界条件为： $$ dp[0] = dp[1] = 1 $$ 时间复杂度为$O(n)$，空间复杂度为$O(n)$。 public int translateNum(int num) { // 为了方便操作，将num的每一位数字存到字符数组chars中 String s = String.valueOf(num); char[] chars = new char[s.length()+1]; for (int i = 0; i = '0')) dp[i] += dp[i-2]; } return dp[s.length()]; } "},"面试题47_礼物的最大价值.html":{"url":"面试题47_礼物的最大价值.html","title":"面试题47：礼物的最大价值","keywords":"","body":"题目描述 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ 题解 使用动态规划的方法，用一个二维数组$dp[i][j]$保存礼物的最大价值，从逻辑上就可以得到，dp数组中第一行和第一列的最大价值就与grid数组中对应值相等（因为第一行和第一列只能起点往一个方向走）。然后其余位置的最大价值怎么求呢？可以比较$dp[i][j]$这个位置上面$dp[i-1][j]$以及左边$dp[i][j-1]$的最大价值，将较大的结果加上$grid[i][j]$的值即得到当前最大价值$dp[i][j]$。 状态转移方程为： $$ dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] $$ public int maxValue(int[][] grid) { int m = grid.length, n = grid[0].length; int[][] dp = new int[m][n]; // 边界条件 dp[0][0] = grid[0][0]; for (int i = 1; i "},"面试题48_最长不含重复字符的子字符串.html":{"url":"面试题48_最长不含重复字符的子字符串.html","title":"面试题48：最长不含重复字符的子字符串","keywords":"","body":"题目描述 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 题解一 采用滑动窗口的思想，初始窗口大小为1，判断窗口内是否有重复字符，若不含重复字符，则更新最大窗口，并在右边扩大窗口。若窗口内含有重复字符，则在左边收缩窗口。 这种方法需要$O(n)$的时间遍历滑动窗口，还需要$O(n)$的时间检查滑动窗口内是否含有重复字符。 总的时间复杂度为$O(n^2)$，空间复杂度为$O(n)$。 以字符串\"arabcacfr\"为例，初始化最大窗口为1，此时窗口内字符串为\"a\"，不含重复字符，则最大窗口为1，窗口右边扩大； 此时窗口内字符为\"ar\"，不含重复字符，最大窗口为2，窗口右边扩大； 此时窗口内字符为\"ara\"，含重复字符，窗口左边收缩； 此时窗口内字符为\"ra\"，不含重复字符，最大窗口为2，窗口右边扩大； 此时窗口内字符为\"rab\"，不含重复字符，最大窗口为3，窗口右边扩大； 此时窗口内字符为\"rabc\"，不含重复字符，最大窗口为4，窗口右边扩大； 此时窗口内字符为\"rabca\"，含重复字符，窗口左边收缩； 此时窗口内字符为\"abca\"，含重复字符，窗口左边收缩； 此时窗口内字符为\"bca\"，不含重复字符，最大窗口为4，窗口右边扩大； 此时窗口内字符为\"bcac\"，含重复字符，窗口左边收缩； 此时窗口内字符为\"cac\"，含重复字符，窗口左边收缩； 此时窗口内字符为\"ac\"，不含重复字符，最大窗口为4，窗口右边扩大； 此时窗口内字符为\"acf\"，不含重复字符，最大窗口为4，窗口右边扩大； 此时窗口内字符为\"acfr\"，不含重复字符，最大窗口为4，窗口右边扩大； 结束，返回最大窗口4。 public int lengthOfLongestSubstring(String s) { if (s.length() == 0) return 0; int maxWindow = 1; int left = 0, right = 1; while (right set = new HashSet<>(); for (int i = 0; i 题解二 上面的滑动窗口仍然可以进行改进，我们可以使用HashSet作为滑动窗口，这样可以在$O(1)$的时间内完成对字符串内重复元素的检查，从而将时间复杂度降低到$O(n)$。 时间复杂度为$O(n)$，空间复杂度为$O(n)$。 public int lengthOfLongestSubstring(String s) { if (s.length() == 0) return 0; int maxWindow = 0, left = 0, right = 0; HashSet set = new HashSet<>(); while (right 题解三 题解二中的滑动窗口最多仍然需要执行$2n$个步骤，我们可以使用HashMap记录字符的位置，而不是仅仅判断字符是否存在。这样，在找到重复元素的时候就可以在更新滑动窗口的时候直接跳过这个元素。也就是说，我们不需要逐渐增加$left$的值，而是可以将滑动窗口的$left$直接更新到上一个重复元素的后面。 时间复杂度为$O(n)$，空间复杂度为$O(n)$。 public int lengthOfLongestSubstring(String s) { if (s.length() == 0) return 0; int maxWindow = 0, left = 0, right = 0; HashMap map = new HashMap<>(); while (right "},"面试题49_丑数.html":{"url":"面试题49_丑数.html","title":"面试题49：丑数","keywords":"","body":"题目描述 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 题解一 第一种方法是逐个数字判断是不是丑数。 判断某个数字是否为丑数的思想很简单，根据丑数的定义，丑数只能被2、3或5整除。因此不断将这个数字除以2、3或5，如果最后结果为1，则说明这个数是丑数；如果不能被整除，则说明不是丑数。 时间复杂度为O(n^2)，空间复杂度为O(1)。 public int GetUglyNumber_Solution(int index) { int count = 0, num = 1; while (true){ if (isUgly(num)) count++; if (count == index) return num; num++; } } private boolean isUgly(int num) { if (num == 1) return true; while (num > 1) { if (num % 2 == 0) num /= 2; else if (num % 3 == 0) num /= 3; else if (num % 5 == 0) num /= 5; else return false; } return num == 1; } 题解二 我们可以创建数组保存已找到的丑数，根据丑数的定义，丑数应该是另一个丑数乘上2、3或5的结果，所以我们用一个数组保存排序好的丑数，每个丑数都是由前面的丑数乘上2、3或5得到的。 为了按序保存丑数，创建三个队列，用于保存丑数分别乘以2、3或5的结果。由于队列先进先出的特性，因此队列中的丑数也是排好序的，所以每次都将三个队列的队头进行比较，将较小值存入数组中，然后再将队头删除。 时间复杂度为O(n)，空间复杂度为O(n)。 public int GetUglyNumber_Solution(int index) { if (index == 0) return 0; Stack stack = new Stack<>(); int min = 1; stack.add(min); Queue queue2 = new LinkedList<>(); Queue queue3 = new LinkedList<>(); Queue queue5 = new LinkedList<>(); while (stack.size() "},"面试题50_I_字符串中第一个只出现一次的字符.html":{"url":"面试题50_I_字符串中第一个只出现一次的字符.html","title":"面试题50-I：字符串中第一个只出现一次的字符","keywords":"","body":"题目描述 在一个字符串(0 题解一 最直观的想法双重循环遍历。扫描字符串中的每个字符，查看是否有其他字符与其重复，输出第一个不重复的字符。 时间复杂度为O(n^2)，空间复杂度为O(1)。 public int FirstNotRepeatingChar(String str) { int index = -1; for (int i = 0; i 题解二 基于哈希表实现，第一遍遍历统计每个字符出现的次数，第二遍遍历找出第一个只出现一次的字符。由于字符种类有限，故哈希表长度是有限的。 时间复杂度为O(n)，空间复杂度为O(1)。 public int FirstNotRepeatingChar(String str) { int index = -1; // 第一遍遍历统计每个字符出现的次数。 HashMap map = new HashMap<>(); for (int i = 0; i "},"面试题50_II_字符流中第一个只出现一次的字符.html":{"url":"面试题50_II_字符流中第一个只出现一次的字符.html","title":"面试题50-II：字符流中第一个只出现一次的字符","keywords":"","body":"题目描述 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符\"go\"时，第一个只出现一次的字符是\"g\"。当从该字符流中读出前六个字符“google\"时，第一个只出现一次的字符是\"l\"。 题解 和上一题一样，一样可以使用哈希表来保存每个字符出现的次数，但由于HashMap是无序的，无法记录输入字符流的顺序，因此使用LinkedHashMap。 时间复杂度为O(n)，空间复杂度为O(1)。 LinkedHashMap map = new LinkedHashMap<>(); public void Insert(char ch) { if (!map.containsKey(ch)) map.put(ch, 1); else map.put(ch, map.get(ch)+1); } public char FirstAppearingOnce() { for (char ch : map.keySet()) { if (map.get(ch) == 1) return ch; } return '#'; } "},"面试题51_数组中的逆序对.html":{"url":"面试题51_数组中的逆序对.html","title":"面试题51：数组中的逆序对","keywords":"","body":"题目描述 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 题解一 第一种方法直接一个暴力双重循环统计逆序对。 时间复杂度为O(n^2)，空间复杂度为O(1)。 public int InversePairs(int[] array) { int count = 0; for (int i = 0; i array[j]) count++; } } return count; } 题解二 第二种方法是用归并排序的思想，但是需要辅助数组。采用分治法，在divide过程中先将数组分隔成一个个小的子数组，然后统计出两个相邻子数组之间逆序对的数量，在统计逆序对的同时进行排序。剑指offer中的解答比较详尽，详细的过程分析还是建议把书找出来看。 时间复杂度为O(nlogn)，空间复杂度为O(n)。 public int InversePairs(int[] array) { if (array.length == 0) return 0; int[] arrayHelper = new int[array.length]; return InversePairsHelper(array, 0, array.length-1, arrayHelper); } private int InversePairsHelper(int[] array, int left, int right, int[] arrayHelper) { if (left >= right) return 0; int mid = (left + right) >> 1; // divide int leftCount = InversePairsHelper(array, left, mid, arrayHelper); int rightCount = InversePairsHelper(array, mid+1, right, arrayHelper); // merge int count = 0; int i = mid, j = right, t = right; while (i >= left && j > mid) { if (array[i] > array[j]) { count += j - mid; count = count= left) arrayHelper[t--] = array[i--]; while (j > mid) arrayHelper[t--] = array[j--]; if (right-left+1 >= 0) System.arraycopy(arrayHelper, left, array, left, right-left+1); return (leftCount + rightCount + count) % 1000000007; } "},"面试题52_两个链表的第一个公共节点.html":{"url":"面试题52_两个链表的第一个公共节点.html","title":"面试题52：两个链表的第一个公共节点","keywords":"","body":"题目描述 输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） 题解 本题可以将两个链表的节点存放在两个栈中，这样两个链表的尾节点就位于栈顶，然后依次比较栈顶是否相同，得到最后一个相同的栈顶元素即为两个链表的第一个公共节点。但是这种方法需要两个辅助栈，时间复杂度和空间复杂度都是O(m+n)。 还有一个更简单的方法，可将空间复杂度降至O(1)。首先遍历两个链表，统计两个链表长度的差值。然后先在较长的链表上先走若干步，步数为这些差值。最后同时在两个链表上开始遍历，找到第一个公共节点。 public ListNode FindFirstCommonNode(ListNode head1, ListNode head2) { if (head1 == null || head2 == null) return null; // 首先遍历两个链表，统计两个链表长度的差值。 ListNode p = head1, q = head2; int count1 = 0, count2 = 0; while (p != null) { count1++; p = p.next; } while (q != null) { count2++; q = q.next; } // 先在较长的链表上先走若干步，步数为这些差值。 if (count1 > count2) { int diff = count1 - count2; while (diff > 0) { head1 = head1.next; diff--; } } else { int diff = count2 - count1; while (diff > 0) { head2 = head2.next; diff--; } } // 最后同时在两个链表上开始遍历，找到第一个公共节点。 while (head1 != head2) { head1 = head1.next; head2 = head2.next; } return head1; } "},"面试题53_在排序数组中查找数字.html":{"url":"面试题53_在排序数组中查找数字.html","title":"面试题53：在排序数组中查找数字","keywords":"","body":"题目描述 统计一个数字在排序数组中出现的次数。 题解一 遍历数组，用一个变量这个数字出现的次数。 时间复杂度为O(n)，空间复杂度为O(1)。 public int GetNumberOfK(int[] array , int k) { int count = 0; for (int num : array) if (num == k) count++; return count; } 题解二 二分查找，先用二分查找算法找到数组中等于k的数字，但是由于k可能有多个。于是分别向左右两边遍历，计算出数组中有多少个数字等于k。 时间复杂度为O(n)，空间复杂度为O(1)。 public int GetNumberOfK2(int[] array, int k) { int len = array.length; if (len == 0) return 0; int left = 0, right = len-1; int begin = 0, end = len-1; // 二分查找 while (left = 0 && array[begin] == k) begin--; while (end 题解三 题解二的时间主要消耗在如何确定排序数组中的第一个k和最后一个k上，那么是不是可以利用二分查找直接找到第一个k和最后一个k？答案是肯定的。 我们通过两次二分查找找到数组中的第一个k和最后一个k，由于数组是有序的，所以可以直接得到相同数字的个数。 时间复杂度为O(logn)，空间复杂度为O(1)。 public int GetNumberOfK(int[] array, int k) { int lower = GetLower(array, k); int upper = GetUpper(array, k); return upper - lower + 1; } private int GetLower(int[] array, int k) { int left = 0, right = array.length-1; while (left = array[mid]) left = mid + 1; else right = mid - 1; } return right; } "},"面试题54_二叉搜索树的第k大节点.html":{"url":"面试题54_二叉搜索树的第k大节点.html","title":"面试题54：二叉搜索树的第k大节点","keywords":"","body":"题目描述 给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三大结点的值为4。 题解 由于二叉搜索树的中序遍历是一个递增序列，因此按中序遍历即可。 int count = 0; public TreeNode KthNode(TreeNode root, int k) { if (root == null) return null; TreeNode node = KthNode(root.left, k); if (node != null) return node; count++; if (count == k) return root; node = KthNode(root.right, k); return node; } "},"面试题55_I_二叉树的深度.html":{"url":"面试题55_I_二叉树的深度.html","title":"面试题55-I：二叉树的深度","keywords":"","body":"题目描述 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 题解一 使用递归的方法比较简单，首先确定递归终止的条件，第二步找返回值，最终取左右子树深度较大的一个加1即可。 public int TreeDepth(TreeNode root) { // 递归终止的条件 if (root == null) return 0; // 找返回值 int left = TreeDepth(root.left); int right = TreeDepth(root.right); // 本级递归应该做什么 return Math.max(left, right) + 1; } 题解二 还可以使用层次遍历的方法。与把二叉树打印成多行类似，用一个变量记录当前层节点的个数，在当前层遍历结束之后将深度加1。 public int TreeDepth2(TreeNode root) { Queue queue = new LinkedList<>(); queue.offer(root); int depth = 0; if (root == null) return depth; while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i "},"面试题55_II_平衡二叉树.html":{"url":"面试题55_II_平衡二叉树.html","title":"面试题55-II：平衡二叉树","keywords":"","body":"题目描述 输入一棵二叉树，判断该二叉树是否是平衡二叉树。 题解一 自顶向下的解法。对每个节点首先求左右子树的深度之差，然后递归判断左右子树是否是平衡二叉树，如果左右子树深度之差小于2，并且左右子树都是平衡二叉树，则根节点也是平衡二叉树。 public boolean IsBalanced_Solution(TreeNode root) { if (root == null) return true; boolean absDepthSatisfy = Math.abs(TreeDepth(root.left) - TreeDepth(root.right)) 题解二 题解一的解法很简洁，但是时间复杂度较高，在上层节点的时候，下层节点可能会被重复遍历，节点的高度会被计算多次。 因此可以考虑自下向上的解法，转化为求树的深度。如果子树是平衡二叉树，则返回子树的深度；否则停止遍历，这样每个节点最多只访问一次。 public boolean IsBalanced_Solution(TreeNode root) { return GetDepth(root) != -1; } private int GetDepth(TreeNode node) { if (node == null) return 0; int left = GetDepth(node.left); if (left == -1) return -1; // 剪枝 int right = GetDepth(node.right); if (right == -1) return -1; // 剪枝 return Math.abs(left-right)>1 ? -1 : Math.max(left, right)+1; } "},"面试题56_I_数组中数字出现的次数.html":{"url":"面试题56_I_数组中数字出现的次数.html","title":"面试题56-I：数组中数字出现的次数","keywords":"","body":"题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 题解一 先将数组排序，然后再找出现一次的数字是比较简单的。 时间复杂度为O(nlogn)，空间复杂度为O(1)。 题解二 还有一种思想是以空间换时间，使用一个哈希表来记录数组中每个数字出现的次数，最终可以得到两个只出现一次的数字。 时间复杂度为O(n)，空间复杂度为O(n)。 题解三 如果将这道题改为数组中只有一个数字只出现一次，那么问题就简单了。我们可以利用异或运算（相同为0，不同为1）的性质： 任何一个数字异或它自己都等于0。 异或运算具有交换律。 因此，如果我们依次遍历异或数组中的每个数字，那么最终出现的结果就是那个只出现一次的数字。 由于这道题中有两个数字只出现一次，所以会复杂一点，但是我们依旧可以将它化解为一个数字的情形。只要将原数组拆成两个数组，每个数组都包含一个只出现一次的数字即可。 我们还是从头到尾一次遍历异或数组中的每个数字，最终会得到那两个只出现一次的数字的异或结果。而这个结果的二进制表示中至少有一位为1，假设我们在结果中找到第一个为1的位的位置，那么就可以对于所有数字按照这个位是否为1划分为两部分。因为那两个只出现一次的数在这个位上异或结果为1（对于异或，相同为0，不同为1），说明这两个数在这个位上是不一样的。使用这个判断条件，可以把这两个数分开。至于那些相同的数字，它们两两配对，一定会分到同一个数组中，这没什么好说的。 得到两个数组之后，我们就将这个问题转化为求数组中一个数字出现一次的问题了。 时间复杂度为O(n)，空间复杂度为O(1)。 public void FindNumsAppearOnce(int[] array, int[] num1, int[] num2) { if (array.length == 0) return; // 得到两个只出现一次的数字的异或结果 int resOR = 0; for (int num : array) resOR ^= num; // 计算第一个为1的位的位置，据此将原数组划分为两个数组 String resORString = Integer.toBinaryString(resOR); int index = 0; for (int i = resORString.length()-1; i >= 0; i--) { if (resORString.charAt(i) == '1') break; else index++; } // 划分数组 ArrayList list1 = new ArrayList<>(); ArrayList list2 = new ArrayList<>(); for (int num : array) { String numString = Integer.toBinaryString(num); int numIndex = numString.length() - 1 - index; if (numIndex >= 0 && numString.charAt(numIndex) == '1') list1.add(num); else list2.add(num); } // 寻找数组中唯一的那个数字 num1[0] = FindNum(list1); num2[0] = FindNum(list2); } private int FindNum(ArrayList list) { int res = 0; for (int num : list) res ^= num; return res; } "},"面试题57_II_和为s的连续正数序列.html":{"url":"面试题57_II_和为s的连续正数序列.html","title":"面试题57-II：和为s的连续正数序列","keywords":"","body":"题目描述 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 题解一 第一种是暴力法，即首先从一个数字开始，然后判断以它为起点的序列和是否等于s。如果以它为起点的序列和以及大于s，则进行剪枝。 public ArrayList> FindContinuousSequence(int sum) { ArrayList> res = new ArrayList<>(); int total = 0; for (int i = 1; i sum) { total = 0; break; } else if (total == sum) { ArrayList arr = new ArrayList<>(); for (int k = i; k 题解二 第二种方法是使用双指针，只是这里的指针代表的不是数组下标，而是数字。开始时把left初始化为1，right初始化为2。每次使用求和公式求序列和： 如果序列和小于sum，则扩大序列的范围，即right++； 如果序列和大于sum，则缩小序列的范围，即left+； 如果序列和等于sum，则找到一个结果。然后扩大序列的范围，即right++。 public ArrayList> FindContinuousSequence(int sum) { int left = 1, right = 2; ArrayList> res = new ArrayList<>(); while (left sum) left++; else { ArrayList arr = new ArrayList<>(); for (int i = left; i "},"面试题57_I_和为s的数字.html":{"url":"面试题57_I_和为s的数字.html","title":"面试题57-I：和为s的数字","keywords":"","body":"题目描述 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的 题解一 第一种是暴力法，即固定一个数字，然后判断其余的数字与它的和是否等于s。 时间复杂度为O(n^2)，空间复杂度为O(1)。 public ArrayList FindNumbersWithSum(int[] array, int sum) { int num1 = Integer.MIN_VALUE, num2 = Integer.MIN_VALUE, minProduct = Integer.MAX_VALUE; for (int i = 0; i res = new ArrayList<>(); if (num1 > Integer.MIN_VALUE && num2 > Integer.MIN_VALUE) { res.add(num1); res.add(num2); } return res; } 题解二 遍历一遍数组，建立一个集合用于存储已遍历的数字。使用num1和num2记录找到的结果，使用minProduct记录最小乘积。如果sum减去当前数字的值不在集合中，就将当前数字存入集合中；如果对应值在集合中，那么就判断当前两个数的乘积是否是乘积最小的，若是，则更新num1和num2。遍历结束后将num1和num2存入数组即可。 时间复杂度为O(n)，空间复杂度为O(n)。 public ArrayList FindNumbersWithSum(int[] array, int sum) { HashSet set = new HashSet<>(); ArrayList res = new ArrayList<>(); int num1 = Integer.MIN_VALUE, num2 = Integer.MIN_VALUE, minProduct = Integer.MAX_VALUE; for (int num : array) { if (set.contains(sum - num)) { if ((sum-num) * num Integer.MIN_VALUE && num2 > Integer.MIN_VALUE) { res.add(num1); res.add(num2); } return res; } 题解三 使用双指针，由于数组已经排序，所以第一次找到的和为s的两个数字必然是乘积最小的。 如果left+right的值小于sum，说明要找的数字在right左边，right--； 如果left+right的值大于sum，说明要找的数字在left右边，left++； 如果left+right的值等于sum，则找到结果。 时间复杂度为O(n)，空间复杂度为O(1)。 public ArrayList FindNumbersWithSum(int[] array, int sum) { int left = 0, right = array.length-1; ArrayList res = new ArrayList<>(); while (left sum) right--; else { res.add(array[left]); res.add(array[right]); break; } } return res; } "},"面试题58_II_左旋转字符串.html":{"url":"面试题58_II_左旋转字符串.html","title":"面试题58-II：左旋转字符串","keywords":"","body":"题目描述 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 题解一 如果允许使用API，那这道题是很简单的。 public String LeftRotateString(String str,int n) { if (str.length() 题解二 但由于本题的核心是考察对于字符串翻转的灵活运用，所以上面使用API的解法就失去了其意义。受到上题翻转单词顺序的启发，我们可以将字符串分为两部分，前n个字母为一部分，剩下的字母为一部分。先单独翻转这两部分，然后再对整体字符串一起翻转。例如对于\"abcdefg\"，n为2。分别翻转\"ab\"和\"cdefg\"，得到bagfedc，然后再对整个字符串进行翻转即可得到\"cdefgab\"。 这个思路可用线性代数的矩阵表示为 $$ YX = (X^T Y^T)^T $$ public String LeftRotateString(String str,int n) { if (str.length() right) return; while (left "},"面试题58_I_翻转单词顺序.html":{"url":"面试题58_I_翻转单词顺序.html","title":"面试题58-I：翻转单词顺序","keywords":"","body":"题目描述 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 题解一 按照空格切分字符串，这样每个单词就会存入到一个字符串数组中，然后再倒序拼接即可。 public String ReverseSentence(String str) { if(str.trim().equals(\"\")) return str; String[] s = str.split(\" \"); StringBuilder sb = new StringBuilder(); for (int i = s.length-1; i >= 0; i--) { sb.append(s[i]); if (i > 0) sb.append(\" \"); } return sb.toString(); } 题解二 但由于本题的核心是考察对于字符串翻转的灵活运用，所以上面使用API的解法其实意义不大。 我们可以通过两次翻转字符串来得到上面的结果。例如对于“student. a am I”，先翻转字符串内所有字符得到\"I ma a .tneduts\"，再对每个单词中的字符顺序进行翻转，就得到了\"I am a students.\"。 public String ReverseSentence2(String str) { if (str.length() == 0) return str; // 先翻转整个字符串 char[] chars = str.toCharArray(); reverse(chars, 0, str.length()-1); // 翻转字符串中的每个单词 int begin = 0, right = 0; for (int i = 0; i right) return; while (left "},"面试题59_I_滑动窗口的最大值.html":{"url":"面试题59_I_滑动窗口的最大值.html","title":"面试题59-I：滑动窗口的最大值","keywords":"","body":"题目描述 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 题解一 利用队列的性质，可将滑动窗口看成一个队列。当窗口滑动时，前面的数字被删除，后面的数字被加入，这就符合队列先进先出的性质。 public ArrayList maxInWindows(int[] nums, int size) { ArrayList res = new ArrayList<>(); if (size == 0 || size > nums.length) return res; Queue queue = new LinkedList<>(); for (int num : nums) { // 当队列的大小等于size时，计算最大值 if (queue.size() == size) { int max = Integer.MIN_VALUE; for (int i : queue) if (i > max) max = i; res.add(max); queue.poll(); } queue.offer(num); } int max = Integer.MIN_VALUE; for (int i : queue) if (i > max) max = i; res.add(max); return res; } 题解二 但是题解一的解法需要对于每一个滑动窗口都遍历一遍，所消耗的时间是比较大的。 我们可以使用双端队列来记录数组的下标，队列头保存当前滑动窗口最大值的下标。当窗口每滑动一次： 对于新增加的值，从队尾开始比较，将队列中比它小的值丢弃。 如果队首元素超出当前滑动窗口，则出队。 将新增加的数组下标入队。 将当前滑动窗口的最大值加入res中。 public ArrayList maxInWindows2(int[] nums, int size) { ArrayList res = new ArrayList<>(); if (size == 0 || size > nums.length) return res; LinkedList queueMax = new LinkedList<>(); for (int i = 0; i = size-1) res.add(nums[queueMax.peekFirst()]); } return res; } "},"面试题60_n个骰子的点数.html":{"url":"面试题60_n个骰子的点数.html","title":"面试题60：n个骰子的点数","keywords":"","body":"题目描述 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。 示例 1: 输入: 1 输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667] 示例 2: 输入: 2 输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778] 题解 本题的题目为n个骰子的点数，这里的点数指的是投掷完n个骰子后，各个和出现的次数，使用浮点数组表示，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。 我们需要算出所有点数出现的次数，最后除以所有点数出现的总次数即可得到概率。使用动态规划的思想，假设$dp[n][s]$为骰子数为n，和为s的情况数量。当有n个骰子时，点数从n取到6n。有状态转移方程： 当$n = 1$时，$dp[1][s] = 1$，其中$s=1,2,3,4,5,6$。 当$n>2$时，$dp[n][s] = dp[n-1][s-1]+dp[n-1][s-2]+dp[n-1][s-3]+dp[n-1][s-4]+dp[n-1][s-5]+dp[n-1][s-6]$ 例如，投掷 2 个骰子时，点数 7 出现的次数相当于投掷出 2 和 5的次数、3 和 4 的次数、1 和 6 的次数之和，而点数1、2、3、4、5、6出现的次数都是 1，故投掷 2 个骰子时点数 7 出现的次数是 6。 int maxValue = 6; public double[] twoSum(int n) { if (n k) dp[i][j] += dp[i-1][j-k]; } } } double all = Math.pow(6, n); double[] res = new double[maxValue*n-n+1]; int index = 0; for (int i = n; i "},"面试题61_扑克牌中的顺子.html":{"url":"面试题61_扑克牌中的顺子.html","title":"面试题61：扑克牌中的顺子","keywords":"","body":"题目描述 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 题解 感觉这道题的题目意思并没有说的很清楚，题目的意思是判断扑克牌是否连续，大小王可以代替任何数字（就和斗地主中的癞子一样）。 本题中使用0代表大小王，我们可以先对数组排序，计算出大小王的数量。然后再计算数组中数的间隔，看大小王能不能将其填充。如果大小王的数量大于等于间隔的数量，那么代表扑克牌中有顺子；否则扑克牌中没有顺子。 public boolean isContinuous(int[] numbers) { if (numbers.length == 0) return false; Arrays.sort(numbers); int kings = 0, totalGap = 0; for (int i = 0; i = totalGap; } "},"面试题62_圆圈中最后剩下的数字.html":{"url":"面试题62_圆圈中最后剩下的数字.html","title":"面试题62：圆圈中最后剩下的数字","keywords":"","body":"题目描述 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 题解一 一个基本的解法是使用环形链表模拟圆圈。首先构建环形链表，然后利用一个指针在环形链表中不断地删除第m个数字。当环形链表中只剩下一个节点时，则得到结果。 这种解法需要在环形链表中遍历很多遍，删除一个节点需要m次运算，共需要遍历n遍，同时还需要一个链表来模拟圆圈。 时间复杂度为O(mn)，空间复杂度为O(n)。 public int LastRemaining_Solution(int n, int m) { if (n == 0) return -1; // 构建环形链表。 ListNode circle = new ListNode(-1); ListNode p = circle; for (int i = 0; i 题解二 也可以在题解一解法的思想上使用java的数据结构LinkList实现。 public int LastRemaining_Solution(int n, int m) { if (n == 0) return -1; LinkedList circle = new LinkedList<>(); // 构建环形链表 for (int i = 0; i 1) { begin = (begin + m - 1) % circle.size(); circle.remove(begin); } return circle.getFirst(); } "},"面试题64_求n的加和.html":{"url":"面试题64_求n的加和.html","title":"面试题64：求n的加和","keywords":"","body":"题目描述 求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 题解 这题使用递归的话是很简单的，但是由于不能使用if语句，无法用if语句实现递归终止条件。 考虑使用三元表达式代替递归，当n大于0的时候进行递归，当n等于0时则终止。相当于在函数开头加上了 if (n == 0) return 0; public int Sum_Solution(int n) { return n == 0 ? 0 : (n + Sum_Solution(n-1)); } "},"面试题65_不用加减乘除做加法.html":{"url":"面试题65_不用加减乘除做加法.html","title":"面试题65：不用加减乘除做加法","keywords":"","body":"题目描述 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 题解 在十进制中，我们使用三步走的方法来做加法（以5和7为例子）： 各位相加而不进位（得到2）。 计算进位值（得到10）。 将前两步得到的结果相加（得到12）。 在二进制中，我们也可以模拟这种方法来做加法（同样以5（101）和7（111）为例子）： 各位相加而不进位（得到sum=010），可用异或操作。 计算进位值（得到carry=1010），可用与操作后左移一位。 将前两步得到的结果相加，即循环前两步（令num1=sum, num2=carry然后循环），当carry=0时终止循环。 public int Add (int num1,int num2) { int sum, carry; while (true) { sum = num1 ^ num2; carry = (num1 & num2) "},"面试题66_构建乘积数组.html":{"url":"面试题66_构建乘积数组.html","title":"面试题66：构建乘积数组","keywords":"","body":"题目描述 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]A[1]...A[i-1]A[i+1]...A[n-1]。不能使用除法。（注意：规定B[0] = A[1] A[2] ... A[n-1]，B[n-1] = A[0] A[1] ... A[n-2];） 题解一 如果能用除法的话，那么可以将A数组中所有元素相乘，使用这个乘积除以A[i]，即可得到B[i]。但由于题目限制不使用除法，另一个直观的解法是将A数组按照i的位置分为两部分，然后连乘这两部分中的所有元素即可。 时间复杂度为O(n^2)，空间复杂度为O(1)。 public int[] multiply(int[] A) { int[] B = new int[A.length]; for (int i = 0; i 题解二 这里是剑指中的思路，非常巧妙。 数组B可以用一个矩阵来创建，此时B[i]的值就是矩阵中每行的乘积。定义C数组保存下三角每行乘积的值，定义D数组保存上三角每行乘积的值。因此C[i] = C[i-1] A[i-1], D[i] = D[i+1] A[i+1]，最后再将C和D数组中的对应元素相乘得到B数组。 时间复杂度为O(n)，空间复杂度为O(n)。 public int[] multiply2(int[] A) { int n = A.length; int[] B = new int[n], C = new int[n], D = new int[n]; C[0] = 1; D[n-1] = 1; // 计算下三角 for (int i = 1; i = 0 ; i--) D[i] = D[i+1] * A[i+1]; // 计算B数组 for (int i = 0; i "},"面试题67_把字符串转换成整数.html":{"url":"面试题67_把字符串转换成整数.html","title":"面试题67：把字符串转换成整数","keywords":"","body":"题目描述 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 题解一 这道题简直细节满满，在边界条件那里试错了无数次，整型总是溢出，最后用了借助了Math.addExact和try catch用来判断整型溢出。Math.addExact和普通加法的区别在于如果和溢出的时候会抛一个 ArithmeticException 异常。看来以后2147483637和-2147483648是会记住了......具体的话有以下几个步骤吧： 跳过前面的空格（如果有的话） 判断第一个字符是不是正号，如果是的话，其后一定要接数字 判断第一个字符是不是负号，如果是的话，保存标志 开始遍历数字，使用 -'0'或Character.digit()得到数字，使用Math.addExact和try catch判断整型溢出 如果不是数字，就结束这个过程，返回答案 class Solution { public int strToInt(String str) { if (str.equals(\"\")) return 0; int index = 0, res = 0; boolean negative = false; while (index '9')) return 0; } // 如果是-，保存标志 if (index 0 && str.charAt(index-1) == '+') return 0; negative = true; index++; } while (index = '0' && str.charAt(index) 题解二 第二种方法是使用正则表达式，不得不说，正则表达式太强大了。 class Solution { public int strToInt(String str) { str = str.trim(); Pattern pattern = Pattern.compile(\"^[\\\\+\\\\-]?\\\\d+\"); Matcher matcher = pattern.matcher(str); int value = 0; if (matcher.find()) { try { value = Integer.parseInt(str.substring(matcher.start(), matcher.end())); } catch (NumberFormatException e) { value = str.charAt(0) == '-' ? Integer.MIN_VALUE : Integer.MAX_VALUE; } } return value; } } "},"面试题68_I_二叉搜索树的最近公共祖先.html":{"url":"面试题68_I_二叉搜索树的最近公共祖先.html","title":"面试题68-I：二叉搜索树的最近公共祖先","keywords":"","body":"题目描述 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 题解 根据二叉搜索树的性质，左子树的值小于根节点的值，右子树的值大于根节点的值。 因此，如果是根节点为最近公共祖先，下面三个条件满足一个即可： 节点p的值等于根节点的值（此时p为q的父节点） 节点q的值等于根节点的值（此时q为p的父节点） 当p、q分别为根节点的左孩子和右孩子的时候 当p、q分别为根节点的右孩子和左孩子的时候 如果三个条件都不满足，那么根节点就不是最近公共祖先，继续往下递归就好了： 如果p和q的值都小于根节点的值，那么在左子树上递归（可以只写p或者q的逻辑，因为如果p的值小于根节点的值，那么q的值就不可能大于根节点的值了（上面已经判断过）） 如果p和q的值都大于根节点的值，那么在右子树上递归（同理） public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (p.val == root.val || q.val == root.val || (p.val root.val) || (p.val > root.val && q.val "},"面试题68_II_二叉树的最近公共祖先.html":{"url":"面试题68_II_二叉树的最近公共祖先.html","title":"面试题68-II：二叉树的最近公共祖先","keywords":"","body":"题目描述 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 题解 这道题的思想是转换为求两个链表的最后一个公共节点。 首先通过深度优先遍历找到二叉树中包含节点p的路径和包含节点q的路径，存入链表中。 然后遍历链表，找到最后一个公共节点，就是二叉树中两个节点的最近公共祖先了。 class Solution { LinkedList> list = new LinkedList<>(); public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { // 对树遍历两遍，找到包含p和q的两条路径，然后再对两条路径找最后一个相同的节点。 dfs(root, p, new LinkedList()); dfs(root, q, new LinkedList()); LinkedList list1 = list.get(0); LinkedList list2 = list.get(1); int i = 0, j = 0; while (i path) { path.add(root); if (root.val == target.val) { list.add(new LinkedList<>(path)); return; } if (root.left != null) dfs(root.left, target, path); if (root.right != null) dfs(root.right, target, path); path.remove(path.size()-1); } } "}}