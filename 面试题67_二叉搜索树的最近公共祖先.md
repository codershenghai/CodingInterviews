# 题目描述

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

![](https://upload-images.jianshu.io/upload_images/16555752-f1edc54bcd8be983.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 题解

根据二叉搜索树的性质，左子树的值小于根节点的值，右子树的值大于根节点的值。

因此，如果是根节点为最近公共祖先，下面三个条件满足一个即可：
1. 节点p的值等于根节点的值（此时p为q的父节点）
2. 节点q的值等于根节点的值（此时q为p的父节点）
3. 当p、q分别为根节点的左孩子和右孩子的时候
4. 当p、q分别为根节点的右孩子和左孩子的时候

如果三个条件都不满足，那么根节点就不是最近公共祖先，继续往下递归就好了：
1. 如果p和q的值都小于根节点的值，那么在左子树上递归（可以只写p或者q的逻辑，因为如果p的值小于根节点的值，那么q的值就不可能大于根节点的值了（上面已经判断过））
2. 如果p和q的值都大于根节点的值，那么在右子树上递归（同理）

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (p.val == root.val || q.val == root.val || (p.val < root.val && q.val > root.val) 
        || (p.val > root.val && q.val < root.val)) 
        return root;
    if (p.val < root.val) return lowestCommonAncestor(root.left, p, q);
    return lowestCommonAncestor(root.right, p, q);
}
```